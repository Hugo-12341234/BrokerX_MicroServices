<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/matching-service/src/main/java/com/microservices/log430/matchingservice/domain/model/entities/OrderBook.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/matching-service/src/main/java/com/microservices/log430/matchingservice/domain/model/entities/OrderBook.java" />
              <option name="originalContent" value="package com.microservices.log430.matchingservice.domain.model.entities;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;public class OrderBook {&#10;    private Long id;&#10;    private String clientOrderId;&#10;    private Long userId;&#10;    private String symbol;&#10;    private String side;&#10;    private String type;&#10;    private Integer quantity;&#10;    private Double price;&#10;    private String duration;&#10;    private LocalDateTime timestamp;&#10;    private String status;&#10;    private String rejectReason;&#10;    private Integer quantityRemaining;&#10;    private Long orderId;&#10;&#10;    // Getters and Setters&#10;    public Long getId() { return id; }&#10;    public void setId(Long id) { this.id = id; }&#10;&#10;    public String getClientOrderId() { return clientOrderId; }&#10;    public void setClientOrderId(String clientOrderId) { this.clientOrderId = clientOrderId; }&#10;&#10;    public Long getUserId() { return userId; }&#10;    public void setUserId(Long userId) { this.userId = userId; }&#10;&#10;    public String getSymbol() { return symbol; }&#10;    public void setSymbol(String symbol) { this.symbol = symbol; }&#10;&#10;    public String getSide() { return side; }&#10;    public void setSide(String side) { this.side = side; }&#10;&#10;    public String getType() { return type; }&#10;    public void setType(String type) { this.type = type; }&#10;&#10;    public Integer getQuantity() { return quantity; }&#10;    public void setQuantity(Integer quantity) { this.quantity = quantity; }&#10;&#10;    public Double getPrice() { return price; }&#10;    public void setPrice(Double price) { this.price = price; }&#10;&#10;    public String getDuration() { return duration; }&#10;    public void setDuration(String duration) { this.duration = duration; }&#10;&#10;    public LocalDateTime getTimestamp() { return timestamp; }&#10;    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }&#10;&#10;    public String getStatus() { return status; }&#10;    public void setStatus(String status) { this.status = status; }&#10;&#10;    public String getRejectReason() { return rejectReason; }&#10;    public void setRejectReason(String rejectReason) { this.rejectReason = rejectReason; }&#10;&#10;    public Integer getQuantityRemaining() { return quantityRemaining; }&#10;    public void setQuantityRemaining(Integer quantityRemaining) { this.quantityRemaining = quantityRemaining; }&#10;&#10;    public Long getOrderId() { return orderId; }&#10;    public void setOrderId(Long orderId) { this.orderId = orderId; }&#10;}&#10;" />
              <option name="updatedContent" value="package com.microservices.log430.matchingservice.domain.model.entities;&#10;&#10;import java.time.LocalDateTime;&#10;&#10;public class OrderBook {&#10;    private Long id;&#10;    private String clientOrderId;&#10;    private Long userId;&#10;    private String symbol;&#10;    private String side;&#10;    private String type;&#10;    private Integer quantity;&#10;    private Double price;&#10;    private String duration;&#10;    private LocalDateTime timestamp;&#10;    private String status;&#10;    private String rejectReason;&#10;    private Integer quantityRemaining;&#10;    private Long orderId;&#10;&#10;    // Getters and Setters&#10;    public Long getId() { return id; }&#10;    public void setId(Long id) { this.id = id; }&#10;&#10;    public String getClientOrderId() { return clientOrderId; }&#10;    public void setClientOrderId(String clientOrderId) { this.clientOrderId = clientOrderId; }&#10;&#10;    public Long getUserId() { return userId; }&#10;    public void setUserId(Long userId) { this.userId = userId; }&#10;&#10;    public String getSymbol() { return symbol; }&#10;    public void setSymbol(String symbol) { this.symbol = symbol; }&#10;&#10;    public String getSide() { return side; }&#10;    public void setSide(String side) { this.side = side; }&#10;&#10;    public String getType() { return type; }&#10;    public void setType(String type) { this.type = type; }&#10;&#10;    public Integer getQuantity() { return quantity; }&#10;    public void setQuantity(Integer quantity) { this.quantity = quantity; }&#10;&#10;    public Double getPrice() { return price; }&#10;    public void setPrice(Double price) { this.price = price; }&#10;&#10;    public String getDuration() { return duration; }&#10;    public void setDuration(String duration) { this.duration = duration; }&#10;&#10;    public LocalDateTime getTimestamp() { return timestamp; }&#10;    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }&#10;&#10;    public String getStatus() { return status; }&#10;    public void setStatus(String status) { this.status = status; }&#10;&#10;    public String getRejectReason() { return rejectReason; }&#10;    public void setRejectReason(String rejectReason) { this.rejectReason = rejectReason; }&#10;&#10;    public Integer getQuantityRemaining() { return quantityRemaining; }&#10;    public void setQuantityRemaining(Integer quantityRemaining) { this.quantityRemaining = quantityRemaining; }&#10;&#10;    public Long getOrderId() { return orderId; }&#10;    public void setOrderId(Long orderId) { this.orderId = orderId; }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/order-service/src/main/java/com/microservices/log430/orderservice/domain/service/OrderService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/order-service/src/main/java/com/microservices/log430/orderservice/domain/service/OrderService.java" />
              <option name="originalContent" value="package com.microservices.log430.orderservice.domain.service;&#10;&#10;import com.microservices.log430.orderservice.adapters.web.dto.OrderRequest;&#10;import com.microservices.log430.orderservice.domain.model.entities.Order;&#10;import com.microservices.log430.orderservice.domain.port.in.OrderPlacementPort;&#10;import com.microservices.log430.orderservice.domain.port.in.PreTradeValidationPort;&#10;import com.microservices.log430.orderservice.domain.port.out.OrderPort;&#10;import com.microservices.log430.orderservice.adapters.external.wallet.WalletClient;&#10;import com.microservices.log430.orderservice.adapters.external.wallet.WalletResponse;&#10;import com.microservices.log430.orderservice.adapters.external.wallet.Wallet;&#10;import com.microservices.log430.orderservice.adapters.external.wallet.WalletUpdateRequest;&#10;import com.microservices.log430.orderservice.adapters.external.matching.MatchingClient;&#10;import com.microservices.log430.orderservice.adapters.external.matching.dto.OrderDTO;&#10;import com.microservices.log430.orderservice.adapters.external.matching.dto.MatchingResult;&#10;import com.microservices.log430.orderservice.adapters.external.matching.dto.ExecutionReportDTO;&#10;import com.microservices.log430.orderservice.adapters.external.matching.dto.OrderBookDTO;&#10;import com.microservices.log430.orderservice.adapters.web.dto.OrderResponse;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.Instant;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;@Service&#10;public class OrderService implements OrderPlacementPort {&#10;    private static final Logger logger = LoggerFactory.getLogger(OrderService.class);&#10;    private final OrderPort orderPort;&#10;    private final PreTradeValidationPort preTradeValidationPort;&#10;    private final WalletClient walletClient;&#10;    private final MatchingClient matchingClient;&#10;&#10;    @Autowired&#10;    public OrderService(OrderPort orderPort, PreTradeValidationPort preTradeValidationPort, WalletClient walletClient, MatchingClient matchingClient) {&#10;        this.orderPort = orderPort;&#10;        this.preTradeValidationPort = preTradeValidationPort;&#10;        this.walletClient = walletClient;&#10;        this.matchingClient = matchingClient;&#10;    }&#10;&#10;    @Override&#10;    public OrderPlacementResult placeOrder(OrderPlacementRequest request, String clientOrderId) {&#10;        logger.info(&quot;Placement d'ordre demandé. userId={}, clientOrderId={}, symbol={}, side={}, type={}, quantité={}, prix={}, durée={}&quot;,&#10;            request.getUserId(), clientOrderId,&#10;            request.getOrderRequest().getSymbol(),&#10;            request.getOrderRequest().getSide(),&#10;            request.getOrderRequest().getType(),&#10;            request.getOrderRequest().getQuantity(),&#10;            request.getOrderRequest().getPrice(),&#10;            request.getOrderRequest().getDuration());&#10;        Optional&lt;Order&gt; existingOrder = orderPort.findByClientOrderId(clientOrderId);&#10;        if (existingOrder.isPresent()) {&#10;            Order existing = existingOrder.get();&#10;            logger.info(&quot;Idempotence : ordre déjà existant. clientOrderId={}, status={}, orderId={}&quot;, clientOrderId, existing.getStatus(), existing.getId());&#10;            return OrderPlacementResult.of(&#10;                existing.getStatus() == Order.OrderStatus.ACCEPTE,&#10;                existing.getId(),&#10;                existing.getStatus().name(),&#10;                existing.getStatus() == Order.OrderStatus.ACCEPTE ?&#10;                    &quot;Ordre placé avec succès&quot; : existing.getRejectReason()&#10;            );&#10;        }&#10;        WalletResponse walletResponse;&#10;        try {&#10;            logger.info(&quot;Appel au wallet-service pour userId={}&quot;, request.getUserId());&#10;            walletResponse = walletClient.getWallet(request.getUserId());&#10;        } catch (Exception ex) {&#10;            logger.error(&quot;Erreur lors de la récupération du portefeuille pour userId={}: {}&quot;, request.getUserId(), ex.getMessage(), ex);&#10;            return OrderPlacementResult.failure(null, &quot;Portefeuille introuvable ou inaccessible&quot;);&#10;        }&#10;        if (walletResponse == null || !walletResponse.isSuccess() || walletResponse.getWallet() == null) {&#10;            logger.warn(&quot;Portefeuille introuvable ou réponse invalide pour userId={}&quot;, request.getUserId());&#10;            return OrderPlacementResult.failure(null, &quot;Portefeuille introuvable&quot;);&#10;        }&#10;        Wallet wallet = walletResponse.getWallet();&#10;        OrderRequest orderRequest = request.getOrderRequest();&#10;        logger.info(&quot;Validation pré-trade pour userId={}, symbol={}, side={}, type={}, quantité={}, prix={}&quot;,&#10;            request.getUserId(), orderRequest.getSymbol(), orderRequest.getSide(), orderRequest.getType(), orderRequest.getQuantity(), orderRequest.getPrice());&#10;        PreTradeValidationPort.ValidationRequest validationRequest = new PreTradeValidationPort.ValidationRequest(&#10;            orderRequest.getSymbol(),&#10;            Order.Side.valueOf(orderRequest.getSide()),&#10;            Order.OrderType.valueOf(orderRequest.getType()),&#10;            orderRequest.getQuantity(),&#10;            orderRequest.getPrice(),&#10;            wallet&#10;        );&#10;        PreTradeValidationPort.ValidationResult validation = preTradeValidationPort.validateOrder(validationRequest);&#10;        Order order = new Order();&#10;        order.setClientOrderId(clientOrderId);&#10;        order.setUserId(request.getUserId());&#10;        order.setSymbol(orderRequest.getSymbol());&#10;        order.setSide(Order.Side.valueOf(orderRequest.getSide()));&#10;        order.setType(Order.OrderType.valueOf(orderRequest.getType()));&#10;        order.setQuantity(orderRequest.getQuantity());&#10;        order.setPrice(orderRequest.getPrice());&#10;        order.setDuration(Order.DurationType.valueOf(orderRequest.getDuration()));&#10;        order.setTimestamp(Instant.now());&#10;        if (!validation.isValid()) {&#10;            logger.warn(&quot;Ordre rejeté pour userId={}, clientOrderId={}, raison={}&quot;, request.getUserId(), clientOrderId, validation.getRejectReason());&#10;            order.setStatus(Order.OrderStatus.REJETE);&#10;            order.setRejectReason(validation.getRejectReason());&#10;            Order savedOrder = orderPort.save(order);&#10;            return OrderPlacementResult.failure(savedOrder.getId(), validation.getRejectReason());&#10;        } else {&#10;            logger.info(&quot;Ordre accepté pour userId={}, clientOrderId={}, orderId={}&quot;, request.getUserId(), clientOrderId, order.getId());&#10;            order.setStatus(Order.OrderStatus.WORKING);&#10;            order.setRejectReason(null);&#10;            Order savedOrder = orderPort.save(order);&#10;&#10;            // Appel au matching-service&#10;            OrderDTO orderDTO = new OrderDTO(&#10;                savedOrder.getId(),&#10;                savedOrder.getClientOrderId(),&#10;                savedOrder.getUserId(),&#10;                savedOrder.getSymbol(),&#10;                savedOrder.getSide().name(),&#10;                savedOrder.getType().name(),&#10;                savedOrder.getQuantity(),&#10;                savedOrder.getPrice(),&#10;                savedOrder.getDuration().name(),&#10;                savedOrder.getTimestamp(),&#10;                savedOrder.getStatus().name(),&#10;                savedOrder.getRejectReason()&#10;            );&#10;            MatchingResult matchingResult = null;&#10;            try {&#10;                matchingResult = matchingClient.matchOrder(orderDTO);&#10;            } catch (Exception e) {&#10;                logger.error(&quot;Erreur lors de l'appel au matching-service : {}&quot;, e.getMessage(), e);&#10;                return OrderPlacementResult.success(savedOrder.getId(), &quot;Ordre placé, mais matching non effectué : &quot; + e.getMessage());&#10;            }&#10;            // Mise à jour du statut du Order selon le résultat du matching-service&#10;            if (matchingResult != null &amp;&amp; matchingResult.updatedOrder != null) {&#10;                OrderBookDTO ob = matchingResult.updatedOrder;&#10;                savedOrder.setStatus(Order.OrderStatus.fromString(ob.getStatus()));&#10;                savedOrder.setRejectReason(ob.getRejectReason());&#10;                // Si applicable, mettre à jour la quantité restante ou autres champs&#10;                // savedOrder.setQuantityRemaining(ob.getQuantityRemaining()); // si champ présent dans Order&#10;                orderPort.save(savedOrder);&#10;            }&#10;&#10;            // Synchronisation des ordres candidats modifiés&#10;            if (matchingResult != null &amp;&amp; matchingResult.modifiedCandidates != null &amp;&amp; !matchingResult.modifiedCandidates.isEmpty()) {&#10;                logger.info(&quot;Synchronisation de {} ordres candidats modifiés&quot;, matchingResult.modifiedCandidates.size());&#10;                for (OrderBookDTO modifiedCandidate : matchingResult.modifiedCandidates) {&#10;                    try {&#10;                        // Trouver l'ordre correspondant dans order-service par clientOrderId&#10;                        Optional&lt;Order&gt; candidateOrder = orderPort.findByClientOrderId(modifiedCandidate.getClientOrderId());&#10;                        if (candidateOrder.isPresent()) {&#10;                            Order candidateOrderEntity = candidateOrder.get();&#10;                            Order.OrderStatus oldStatus = candidateOrderEntity.getStatus();&#10;                            candidateOrderEntity.setStatus(Order.OrderStatus.fromString(modifiedCandidate.getStatus()));&#10;                            orderPort.save(candidateOrderEntity);&#10;                            logger.info(&quot;Ordre candidat synchronisé : clientOrderId={}, userId={}, {} -&gt; {}&quot;,&#10;                                       candidateOrderEntity.getClientOrderId(), candidateOrderEntity.getUserId(), oldStatus, candidateOrderEntity.getStatus());&#10;                        } else {&#10;                            logger.warn(&quot;Ordre candidat modifié non trouvé dans order-service : clientOrderId={}&quot;,&#10;                                       modifiedCandidate.getClientOrderId());&#10;                        }&#10;                    } catch (Exception e) {&#10;                        logger.error(&quot;Erreur lors de la synchronisation de l'ordre candidat clientOrderId={} : {}&quot;,&#10;                                   modifiedCandidate.getClientOrderId(), e.getMessage(), e);&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Mise à jour des portefeuilles pour chaque deal&#10;            List&lt;String&gt; deals = new ArrayList&lt;&gt;();&#10;            if (matchingResult != null &amp;&amp; matchingResult.executions != null) {&#10;                for (ExecutionReportDTO exec : matchingResult.executions) {&#10;                    try {&#10;                        // Skip update si userId == 9999 (seed)&#10;                        if (exec.getBuyerUserId() != null &amp;&amp; exec.getBuyerUserId() == 9999L) {&#10;                            logger.info(&quot;Skip update portefeuille pour l'acheteur userId=9999 (seed)&quot;);&#10;                        } else {&#10;                            WalletUpdateRequest buyerUpdate = new WalletUpdateRequest(&#10;                                exec.getBuyerUserId(),&#10;                                exec.getSymbol(),&#10;                                exec.getFillQuantity(),&#10;                                -exec.getFillPrice() * exec.getFillQuantity()&#10;                            );&#10;                            logger.info(&quot;Nous allons mettre à jour le portefeuille de l'acheteur&quot;);&#10;                            walletClient.updateWallet(buyerUpdate);&#10;                            logger.info(&quot;Portefeuille mis à jour pour l'acheteur userId={} : +{} {} et -{} en cash&quot;,&#10;                                exec.getBuyerUserId(), exec.getFillQuantity(), exec.getSymbol(), exec.getFillPrice() * exec.getFillQuantity());&#10;                        }&#10;                        // Skip update si userId == 9999 (seed)&#10;                        if (exec.getSellerUserId() != null &amp;&amp; exec.getSellerUserId() == 9999L) {&#10;                            logger.info(&quot;Skip update portefeuille pour le vendeur userId=9999 (seed)&quot;);&#10;                        } else {&#10;                            WalletUpdateRequest sellerUpdate = new WalletUpdateRequest(&#10;                                exec.getSellerUserId(),&#10;                                exec.getSymbol(),&#10;                                -exec.getFillQuantity(),&#10;                                exec.getFillPrice() * exec.getFillQuantity()&#10;                            );&#10;                            logger.info(&quot;Nous allons mettre à jour le portefeuille du vendeur&quot;);&#10;                            walletClient.updateWallet(sellerUpdate);&#10;                            logger.info(&quot;Portefeuille mis à jour pour le vendeur userId={} : -{} {} et +{} en cash&quot;,&#10;                                exec.getSellerUserId(), exec.getFillQuantity(), exec.getSymbol(), exec.getFillPrice() * exec.getFillQuantity());&#10;                        }&#10;                        deals.add(String.format(&quot;Deal: %d %s @ %.2f entre acheteur %d et vendeur %d&quot;, exec.getFillQuantity(), exec.getSymbol(), exec.getFillPrice(), exec.getBuyerUserId(), exec.getSellerUserId()));&#10;                    } catch (Exception ex) {&#10;                        logger.error(&quot;Erreur lors de la mise à jour du portefeuille pour le deal : {}&quot;, ex.getMessage(), ex);&#10;                    }&#10;                }&#10;            }&#10;            // Gestion des annulations&#10;            String annulationInfo = &quot;&quot;;&#10;            if (matchingResult != null &amp;&amp; matchingResult.updatedOrder != null) {&#10;                OrderBookDTO ob = matchingResult.updatedOrder;&#10;                if (&quot;REJETE&quot;.equals(ob.getStatus()) || (ob.getQuantityRemaining() &gt; 0 &amp;&amp; ob.getQuantityRemaining() &lt; savedOrder.getQuantity())) {&#10;                    annulationInfo = ob.getRejectReason() != null ? ob.getRejectReason() : &quot;Ordre partiellement ou totalement annulé.&quot;;&#10;                }&#10;            }&#10;            // Construction du message pour le frontend&#10;            StringBuilder message = new StringBuilder();&#10;            if (matchingResult != null &amp;&amp; matchingResult.updatedOrder != null) {&#10;                OrderBookDTO ob = matchingResult.updatedOrder;&#10;                int qtyInitial = savedOrder.getQuantity();&#10;                int qtyFilled = qtyInitial - ob.getQuantityRemaining();&#10;                int qtyCancelled = ob.getQuantityRemaining();&#10;                String type = savedOrder.getDuration().name();&#10;                if (&quot;FOK&quot;.equalsIgnoreCase(type)) {&#10;                    if (qtyFilled == 0) {&#10;                        message.append(&quot;Ordre FOK annulé : la quantité totale n'était pas disponible, aucune exécution.&quot;);&#10;                    } else {&#10;                        message.append(&quot;Ordre FOK exécuté : &quot;).append(qtyFilled).append(&quot; fulfilled.&quot;);&#10;                    }&#10;                } else if (&quot;IOC&quot;.equalsIgnoreCase(type)) {&#10;                    if (qtyFilled == 0) {&#10;                        message.append(&quot;Ordre IOC annulé : aucune exécution possible.&quot;);&#10;                    } else {&#10;                        message.append(&quot;Ordre IOC partiellement exécuté : &quot;)&#10;                               .append(qtyFilled).append(&quot; fulfilled, &quot;)&#10;                               .append(qtyCancelled).append(&quot; annulés.&quot;);&#10;                    }&#10;                } else if (&quot;DAY&quot;.equalsIgnoreCase(type)) {&#10;                    if (qtyFilled == 0) {&#10;                        message.append(&quot;Ordre DAY ouvert : aucune exécution pour l'instant, reste ouvert 24h.&quot;);&#10;                    } else if (qtyCancelled &gt; 0) {&#10;                        message.append(&quot;Ordre DAY partiellement exécuté : &quot;)&#10;                               .append(qtyFilled).append(&quot; fulfilled, reste ouvert pour &quot;)&#10;                               .append(qtyCancelled).append(&quot; jusqu'à expiration (24h).&quot;);&#10;                    } else {&#10;                        message.append(&quot;Ordre DAY entièrement exécuté : &quot;).append(qtyFilled).append(&quot; fulfilled.&quot;);&#10;                    }&#10;                } else {&#10;                    message.append(&quot;Ordre placé avec succès.&quot;);&#10;                }&#10;                if (!deals.isEmpty()) {&#10;                    message.append(&quot; Exécutions: &quot;).append(String.join(&quot;, &quot;, deals));&#10;                }&#10;                if (ob.getRejectReason() != null &amp;&amp; !ob.getRejectReason().isEmpty()) {&#10;                    message.append(&quot; Raison: &quot;).append(ob.getRejectReason());&#10;                }&#10;            } else {&#10;                message.append(&quot;Ordre placé avec succès.&quot;);&#10;                if (!deals.isEmpty()) {&#10;                    message.append(&quot; Exécutions: &quot;).append(String.join(&quot;, &quot;, deals));&#10;                }&#10;                if (!annulationInfo.isEmpty()) {&#10;                    message.append(&quot; Annulation: &quot;).append(annulationInfo);&#10;                }&#10;            }&#10;            return OrderPlacementResult.success(savedOrder.getId(), message.toString());&#10;        }&#10;    }&#10;&#10;    public OrderResponse findOrderById(Long orderId) {&#10;        Optional&lt;Order&gt; orderOpt = orderPort.findById(orderId);&#10;        if (orderOpt.isEmpty()) return null;&#10;        Order order = orderOpt.get();&#10;        return OrderResponse.fromOrder(order);&#10;    }&#10;&#10;    @Override&#10;    public OrderResponse modifyOrder(Long orderId, OrderRequest orderRequest, Long userId) {&#10;        Optional&lt;Order&gt; orderOpt = orderPort.findById(orderId);&#10;        if (orderOpt.isEmpty()) throw new IllegalArgumentException(&quot;Ordre non trouvé&quot;);&#10;        Order order = orderOpt.get();&#10;        // Vérification du verrouillage optimiste&#10;        Long versionBefore = order.getVersion();&#10;        if (Order.OrderStatus.FILLED.equals(order.getStatus()) || Order.OrderStatus.CANCELLED.equals(order.getStatus())) {&#10;            throw new IllegalStateException(&quot;Impossible de modifier un ordre rempli ou annulé&quot;);&#10;        }&#10;        // Contrôles pré-trade&#10;        PreTradeValidationPort.ValidationRequest validationRequest = new PreTradeValidationPort.ValidationRequest(&#10;            orderRequest.getSymbol(),&#10;            Order.Side.valueOf(orderRequest.getSide()),&#10;            Order.OrderType.valueOf(orderRequest.getType()),&#10;            orderRequest.getQuantity(),&#10;            orderRequest.getPrice(),&#10;            walletClient.getWallet(userId).getWallet()&#10;        );&#10;        PreTradeValidationPort.ValidationResult validation = preTradeValidationPort.validateOrder(validationRequest);&#10;        if (!validation.isValid()) {&#10;            order.setStatus(Order.OrderStatus.REJETE);&#10;            order.setRejectReason(validation.getRejectReason());&#10;            orderPort.save(order);&#10;            throw new IllegalStateException(&quot;Modification rejetée : &quot; + validation.getRejectReason());&#10;        }&#10;        // Appliquer les modifications&#10;        order.setQuantity(orderRequest.getQuantity());&#10;        order.setPrice(orderRequest.getPrice());&#10;        order.setType(Order.OrderType.valueOf(orderRequest.getType()));&#10;        order.setDuration(Order.DurationType.valueOf(orderRequest.getDuration()));&#10;        order.setTimestamp(Instant.now());&#10;        Order updatedOrder = orderPort.save(order);&#10;        // Vérification du verrouillage optimiste&#10;        if (!versionBefore.equals(updatedOrder.getVersion() - 1)) {&#10;            throw new RuntimeException(&quot;Conflit de version : l'ordre a été modifié par une autre transaction&quot;);&#10;        }&#10;        // Synchronisation avec le matching-service&#10;        OrderDTO orderDTO = new OrderDTO(&#10;            updatedOrder.getId(),&#10;            updatedOrder.getClientOrderId(),&#10;            updatedOrder.getUserId(),&#10;            updatedOrder.getSymbol(),&#10;            updatedOrder.getSide().name(),&#10;            updatedOrder.getType().name(),&#10;            updatedOrder.getQuantity(),&#10;            updatedOrder.getPrice(),&#10;            updatedOrder.getDuration().name(),&#10;            updatedOrder.getTimestamp(),&#10;            updatedOrder.getStatus().name(),&#10;            updatedOrder.getRejectReason()&#10;        );&#10;        try {&#10;            matchingClient.modifyOrder(orderDTO);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Erreur lors de la synchronisation avec le matching-service : {}&quot;, e.getMessage(), e);&#10;        }&#10;        return OrderResponse.fromOrder(updatedOrder);&#10;    }&#10;&#10;    public OrderResponse cancelOrder(Long orderId, Long userId) {&#10;        Optional&lt;Order&gt; orderOpt = orderPort.findById(orderId);&#10;        if (orderOpt.isEmpty()) throw new IllegalArgumentException(&quot;Ordre non trouvé&quot;);&#10;        Order order = orderOpt.get();&#10;        Long versionBefore = order.getVersion();&#10;        if (Order.OrderStatus.FILLED.equals(order.getStatus()) || Order.OrderStatus.CANCELLED.equals(order.getStatus())) {&#10;            throw new IllegalStateException(&quot;Impossible d'annuler un ordre rempli ou déjà annulé&quot;);&#10;        }&#10;        order.setStatus(Order.OrderStatus.CANCELLED);&#10;        order.setTimestamp(Instant.now());&#10;        Order updatedOrder = orderPort.save(order);&#10;        if (!versionBefore.equals(updatedOrder.getVersion() - 1)) {&#10;            throw new RuntimeException(&quot;Conflit de version : l'ordre a été modifié par une autre transaction&quot;);&#10;        }&#10;        // Synchronisation avec le matching-service&#10;        OrderDTO orderDTO = new OrderDTO(&#10;            updatedOrder.getId(),&#10;            updatedOrder.getClientOrderId(),&#10;            updatedOrder.getUserId(),&#10;            updatedOrder.getSymbol(),&#10;            updatedOrder.getSide().name(),&#10;            updatedOrder.getType().name(),&#10;            updatedOrder.getQuantity(),&#10;            updatedOrder.getPrice(),&#10;            updatedOrder.getDuration().name(),&#10;            updatedOrder.getTimestamp(),&#10;            updatedOrder.getStatus().name(),&#10;            updatedOrder.getRejectReason()&#10;        );&#10;        try {&#10;            matchingClient.cancelOrder(orderDTO);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Erreur lors de la synchronisation avec le matching-service : {}&quot;, e.getMessage(), e);&#10;        }&#10;        return OrderResponse.fromOrder(updatedOrder);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.microservices.log430.orderservice.domain.service;&#10;&#10;import com.microservices.log430.orderservice.adapters.web.dto.OrderRequest;&#10;import com.microservices.log430.orderservice.domain.model.entities.Order;&#10;import com.microservices.log430.orderservice.domain.port.in.OrderPlacementPort;&#10;import com.microservices.log430.orderservice.domain.port.in.PreTradeValidationPort;&#10;import com.microservices.log430.orderservice.domain.port.out.OrderPort;&#10;import com.microservices.log430.orderservice.adapters.external.wallet.WalletClient;&#10;import com.microservices.log430.orderservice.adapters.external.wallet.WalletResponse;&#10;import com.microservices.log430.orderservice.adapters.external.wallet.Wallet;&#10;import com.microservices.log430.orderservice.adapters.external.wallet.WalletUpdateRequest;&#10;import com.microservices.log430.orderservice.adapters.external.matching.MatchingClient;&#10;import com.microservices.log430.orderservice.adapters.external.matching.dto.OrderDTO;&#10;import com.microservices.log430.orderservice.adapters.external.matching.dto.MatchingResult;&#10;import com.microservices.log430.orderservice.adapters.external.matching.dto.ExecutionReportDTO;&#10;import com.microservices.log430.orderservice.adapters.external.matching.dto.OrderBookDTO;&#10;import com.microservices.log430.orderservice.adapters.web.dto.OrderResponse;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.Instant;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;&#10;@Service&#10;public class OrderService implements OrderPlacementPort {&#10;    private static final Logger logger = LoggerFactory.getLogger(OrderService.class);&#10;    private final OrderPort orderPort;&#10;    private final PreTradeValidationPort preTradeValidationPort;&#10;    private final WalletClient walletClient;&#10;    private final MatchingClient matchingClient;&#10;&#10;    @Autowired&#10;    public OrderService(OrderPort orderPort, PreTradeValidationPort preTradeValidationPort, WalletClient walletClient, MatchingClient matchingClient) {&#10;        this.orderPort = orderPort;&#10;        this.preTradeValidationPort = preTradeValidationPort;&#10;        this.walletClient = walletClient;&#10;        this.matchingClient = matchingClient;&#10;    }&#10;&#10;    @Override&#10;    public OrderPlacementResult placeOrder(OrderPlacementRequest request, String clientOrderId) {&#10;        logger.info(&quot;Placement d'ordre demandé. userId={}, clientOrderId={}, symbol={}, side={}, type={}, quantité={}, prix={}, durée={}&quot;,&#10;            request.getUserId(), clientOrderId,&#10;            request.getOrderRequest().getSymbol(),&#10;            request.getOrderRequest().getSide(),&#10;            request.getOrderRequest().getType(),&#10;            request.getOrderRequest().getQuantity(),&#10;            request.getOrderRequest().getPrice(),&#10;            request.getOrderRequest().getDuration());&#10;        Optional&lt;Order&gt; existingOrder = orderPort.findByClientOrderId(clientOrderId);&#10;        if (existingOrder.isPresent()) {&#10;            Order existing = existingOrder.get();&#10;            logger.info(&quot;Idempotence : ordre déjà existant. clientOrderId={}, status={}, orderId={}&quot;, clientOrderId, existing.getStatus(), existing.getId());&#10;            return OrderPlacementResult.of(&#10;                existing.getStatus() == Order.OrderStatus.ACCEPTE,&#10;                existing.getId(),&#10;                existing.getStatus().name(),&#10;                existing.getStatus() == Order.OrderStatus.ACCEPTE ?&#10;                    &quot;Ordre placé avec succès&quot; : existing.getRejectReason()&#10;            );&#10;        }&#10;        WalletResponse walletResponse;&#10;        try {&#10;            logger.info(&quot;Appel au wallet-service pour userId={}&quot;, request.getUserId());&#10;            walletResponse = walletClient.getWallet(request.getUserId());&#10;        } catch (Exception ex) {&#10;            logger.error(&quot;Erreur lors de la récupération du portefeuille pour userId={}: {}&quot;, request.getUserId(), ex.getMessage(), ex);&#10;            return OrderPlacementResult.failure(null, &quot;Portefeuille introuvable ou inaccessible&quot;);&#10;        }&#10;        if (walletResponse == null || !walletResponse.isSuccess() || walletResponse.getWallet() == null) {&#10;            logger.warn(&quot;Portefeuille introuvable ou réponse invalide pour userId={}&quot;, request.getUserId());&#10;            return OrderPlacementResult.failure(null, &quot;Portefeuille introuvable&quot;);&#10;        }&#10;        Wallet wallet = walletResponse.getWallet();&#10;        OrderRequest orderRequest = request.getOrderRequest();&#10;        logger.info(&quot;Validation pré-trade pour userId={}, symbol={}, side={}, type={}, quantité={}, prix={}&quot;,&#10;            request.getUserId(), orderRequest.getSymbol(), orderRequest.getSide(), orderRequest.getType(), orderRequest.getQuantity(), orderRequest.getPrice());&#10;        PreTradeValidationPort.ValidationRequest validationRequest = new PreTradeValidationPort.ValidationRequest(&#10;            orderRequest.getSymbol(),&#10;            Order.Side.valueOf(orderRequest.getSide()),&#10;            Order.OrderType.valueOf(orderRequest.getType()),&#10;            orderRequest.getQuantity(),&#10;            orderRequest.getPrice(),&#10;            wallet&#10;        );&#10;        PreTradeValidationPort.ValidationResult validation = preTradeValidationPort.validateOrder(validationRequest);&#10;        Order order = new Order();&#10;        order.setClientOrderId(clientOrderId);&#10;        order.setUserId(request.getUserId());&#10;        order.setSymbol(orderRequest.getSymbol());&#10;        order.setSide(Order.Side.valueOf(orderRequest.getSide()));&#10;        order.setType(Order.OrderType.valueOf(orderRequest.getType()));&#10;        order.setQuantity(orderRequest.getQuantity());&#10;        order.setPrice(orderRequest.getPrice());&#10;        order.setDuration(Order.DurationType.valueOf(orderRequest.getDuration()));&#10;        order.setTimestamp(Instant.now());&#10;        if (!validation.isValid()) {&#10;            logger.warn(&quot;Ordre rejeté pour userId={}, clientOrderId={}, raison={}&quot;, request.getUserId(), clientOrderId, validation.getRejectReason());&#10;            order.setStatus(Order.OrderStatus.REJETE);&#10;            order.setRejectReason(validation.getRejectReason());&#10;            Order savedOrder = orderPort.save(order);&#10;            return OrderPlacementResult.failure(savedOrder.getId(), validation.getRejectReason());&#10;        } else {&#10;            logger.info(&quot;Ordre accepté pour userId={}, clientOrderId={}, orderId={}&quot;, request.getUserId(), clientOrderId, order.getId());&#10;            order.setStatus(Order.OrderStatus.WORKING);&#10;            order.setRejectReason(null);&#10;            Order savedOrder = orderPort.save(order);&#10;&#10;            // Appel au matching-service&#10;            OrderDTO orderDTO = new OrderDTO(&#10;                savedOrder.getId(),&#10;                savedOrder.getClientOrderId(),&#10;                savedOrder.getUserId(),&#10;                savedOrder.getSymbol(),&#10;                savedOrder.getSide().name(),&#10;                savedOrder.getType().name(),&#10;                savedOrder.getQuantity(),&#10;                savedOrder.getPrice(),&#10;                savedOrder.getDuration().name(),&#10;                savedOrder.getTimestamp(),&#10;                savedOrder.getStatus().name(),&#10;                savedOrder.getRejectReason()&#10;            );&#10;            MatchingResult matchingResult = null;&#10;            try {&#10;                matchingResult = matchingClient.matchOrder(orderDTO);&#10;            } catch (Exception e) {&#10;                logger.error(&quot;Erreur lors de l'appel au matching-service : {}&quot;, e.getMessage(), e);&#10;                return OrderPlacementResult.success(savedOrder.getId(), &quot;Ordre placé, mais matching non effectué : &quot; + e.getMessage());&#10;            }&#10;            // Mise à jour du statut du Order selon le résultat du matching-service&#10;            if (matchingResult != null &amp;&amp; matchingResult.updatedOrder != null) {&#10;                OrderBookDTO ob = matchingResult.updatedOrder;&#10;                savedOrder.setStatus(Order.OrderStatus.fromString(ob.getStatus()));&#10;                savedOrder.setRejectReason(ob.getRejectReason());&#10;                // Si applicable, mettre à jour la quantité restante ou autres champs&#10;                // savedOrder.setQuantityRemaining(ob.getQuantityRemaining()); // si champ présent dans Order&#10;                orderPort.save(savedOrder);&#10;            }&#10;&#10;            // Synchronisation des ordres candidats modifiés&#10;            if (matchingResult != null &amp;&amp; matchingResult.modifiedCandidates != null &amp;&amp; !matchingResult.modifiedCandidates.isEmpty()) {&#10;                logger.info(&quot;Synchronisation de {} ordres candidats modifiés&quot;, matchingResult.modifiedCandidates.size());&#10;                for (OrderBookDTO modifiedCandidate : matchingResult.modifiedCandidates) {&#10;                    try {&#10;                        // Trouver l'ordre correspondant dans order-service par clientOrderId&#10;                        Optional&lt;Order&gt; candidateOrder = orderPort.findByClientOrderId(modifiedCandidate.getClientOrderId());&#10;                        if (candidateOrder.isPresent()) {&#10;                            Order candidateOrderEntity = candidateOrder.get();&#10;                            Order.OrderStatus oldStatus = candidateOrderEntity.getStatus();&#10;                            candidateOrderEntity.setStatus(Order.OrderStatus.fromString(modifiedCandidate.getStatus()));&#10;                            orderPort.save(candidateOrderEntity);&#10;                            logger.info(&quot;Ordre candidat synchronisé : clientOrderId={}, userId={}, {} -&gt; {}&quot;,&#10;                                       candidateOrderEntity.getClientOrderId(), candidateOrderEntity.getUserId(), oldStatus, candidateOrderEntity.getStatus());&#10;                        } else {&#10;                            logger.warn(&quot;Ordre candidat modifié non trouvé dans order-service : clientOrderId={}&quot;,&#10;                                       modifiedCandidate.getClientOrderId());&#10;                        }&#10;                    } catch (Exception e) {&#10;                        logger.error(&quot;Erreur lors de la synchronisation de l'ordre candidat clientOrderId={} : {}&quot;,&#10;                                   modifiedCandidate.getClientOrderId(), e.getMessage(), e);&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Mise à jour des portefeuilles pour chaque deal&#10;            List&lt;String&gt; deals = new ArrayList&lt;&gt;();&#10;            if (matchingResult != null &amp;&amp; matchingResult.executions != null) {&#10;                for (ExecutionReportDTO exec : matchingResult.executions) {&#10;                    try {&#10;                        // Skip update si userId == 9999 (seed)&#10;                        if (exec.getBuyerUserId() != null &amp;&amp; exec.getBuyerUserId() == 9999L) {&#10;                            logger.info(&quot;Skip update portefeuille pour l'acheteur userId=9999 (seed)&quot;);&#10;                        } else {&#10;                            WalletUpdateRequest buyerUpdate = new WalletUpdateRequest(&#10;                                exec.getBuyerUserId(),&#10;                                exec.getSymbol(),&#10;                                exec.getFillQuantity(),&#10;                                -exec.getFillPrice() * exec.getFillQuantity()&#10;                            );&#10;                            logger.info(&quot;Nous allons mettre à jour le portefeuille de l'acheteur&quot;);&#10;                            walletClient.updateWallet(buyerUpdate);&#10;                            logger.info(&quot;Portefeuille mis à jour pour l'acheteur userId={} : +{} {} et -{} en cash&quot;,&#10;                                exec.getBuyerUserId(), exec.getFillQuantity(), exec.getSymbol(), exec.getFillPrice() * exec.getFillQuantity());&#10;                        }&#10;                        // Skip update si userId == 9999 (seed)&#10;                        if (exec.getSellerUserId() != null &amp;&amp; exec.getSellerUserId() == 9999L) {&#10;                            logger.info(&quot;Skip update portefeuille pour le vendeur userId=9999 (seed)&quot;);&#10;                        } else {&#10;                            WalletUpdateRequest sellerUpdate = new WalletUpdateRequest(&#10;                                exec.getSellerUserId(),&#10;                                exec.getSymbol(),&#10;                                -exec.getFillQuantity(),&#10;                                exec.getFillPrice() * exec.getFillQuantity()&#10;                            );&#10;                            logger.info(&quot;Nous allons mettre à jour le portefeuille du vendeur&quot;);&#10;                            walletClient.updateWallet(sellerUpdate);&#10;                            logger.info(&quot;Portefeuille mis à jour pour le vendeur userId={} : -{} {} et +{} en cash&quot;,&#10;                                exec.getSellerUserId(), exec.getFillQuantity(), exec.getSymbol(), exec.getFillPrice() * exec.getFillQuantity());&#10;                        }&#10;                        deals.add(String.format(&quot;Deal: %d %s @ %.2f entre acheteur %d et vendeur %d&quot;, exec.getFillQuantity(), exec.getSymbol(), exec.getFillPrice(), exec.getBuyerUserId(), exec.getSellerUserId()));&#10;                    } catch (Exception ex) {&#10;                        logger.error(&quot;Erreur lors de la mise à jour du portefeuille pour le deal : {}&quot;, ex.getMessage(), ex);&#10;                    }&#10;                }&#10;            }&#10;            // Gestion des annulations&#10;            String annulationInfo = &quot;&quot;;&#10;            if (matchingResult != null &amp;&amp; matchingResult.updatedOrder != null) {&#10;                OrderBookDTO ob = matchingResult.updatedOrder;&#10;                if (&quot;REJETE&quot;.equals(ob.getStatus()) || (ob.getQuantityRemaining() &gt; 0 &amp;&amp; ob.getQuantityRemaining() &lt; savedOrder.getQuantity())) {&#10;                    annulationInfo = ob.getRejectReason() != null ? ob.getRejectReason() : &quot;Ordre partiellement ou totalement annulé.&quot;;&#10;                }&#10;            }&#10;            // Construction du message pour le frontend&#10;            StringBuilder message = new StringBuilder();&#10;            if (matchingResult != null &amp;&amp; matchingResult.updatedOrder != null) {&#10;                OrderBookDTO ob = matchingResult.updatedOrder;&#10;                int qtyInitial = savedOrder.getQuantity();&#10;                int qtyFilled = qtyInitial - ob.getQuantityRemaining();&#10;                int qtyCancelled = ob.getQuantityRemaining();&#10;                String type = savedOrder.getDuration().name();&#10;                if (&quot;FOK&quot;.equalsIgnoreCase(type)) {&#10;                    if (qtyFilled == 0) {&#10;                        message.append(&quot;Ordre FOK annulé : la quantité totale n'était pas disponible, aucune exécution.&quot;);&#10;                    } else {&#10;                        message.append(&quot;Ordre FOK exécuté : &quot;).append(qtyFilled).append(&quot; fulfilled.&quot;);&#10;                    }&#10;                } else if (&quot;IOC&quot;.equalsIgnoreCase(type)) {&#10;                    if (qtyFilled == 0) {&#10;                        message.append(&quot;Ordre IOC annulé : aucune exécution possible.&quot;);&#10;                    } else {&#10;                        message.append(&quot;Ordre IOC partiellement exécuté : &quot;)&#10;                               .append(qtyFilled).append(&quot; fulfilled, &quot;)&#10;                               .append(qtyCancelled).append(&quot; annulés.&quot;);&#10;                    }&#10;                } else if (&quot;DAY&quot;.equalsIgnoreCase(type)) {&#10;                    if (qtyFilled == 0) {&#10;                        message.append(&quot;Ordre DAY ouvert : aucune exécution pour l'instant, reste ouvert 24h.&quot;);&#10;                    } else if (qtyCancelled &gt; 0) {&#10;                        message.append(&quot;Ordre DAY partiellement exécuté : &quot;)&#10;                               .append(qtyFilled).append(&quot; fulfilled, reste ouvert pour &quot;)&#10;                               .append(qtyCancelled).append(&quot; jusqu'à expiration (24h).&quot;);&#10;                    } else {&#10;                        message.append(&quot;Ordre DAY entièrement exécuté : &quot;).append(qtyFilled).append(&quot; fulfilled.&quot;);&#10;                    }&#10;                } else {&#10;                    message.append(&quot;Ordre placé avec succès.&quot;);&#10;                }&#10;                if (!deals.isEmpty()) {&#10;                    message.append(&quot; Exécutions: &quot;).append(String.join(&quot;, &quot;, deals));&#10;                }&#10;                if (ob.getRejectReason() != null &amp;&amp; !ob.getRejectReason().isEmpty()) {&#10;                    message.append(&quot; Raison: &quot;).append(ob.getRejectReason());&#10;                }&#10;            } else {&#10;                message.append(&quot;Ordre placé avec succès.&quot;);&#10;                if (!deals.isEmpty()) {&#10;                    message.append(&quot; Exécutions: &quot;).append(String.join(&quot;, &quot;, deals));&#10;                }&#10;                if (!annulationInfo.isEmpty()) {&#10;                    message.append(&quot; Annulation: &quot;).append(annulationInfo);&#10;                }&#10;            }&#10;            return OrderPlacementResult.success(savedOrder.getId(), message.toString());&#10;        }&#10;    }&#10;&#10;    public OrderResponse findOrderById(Long orderId) {&#10;        Optional&lt;Order&gt; orderOpt = orderPort.findById(orderId);&#10;        if (orderOpt.isEmpty()) return null;&#10;        Order order = orderOpt.get();&#10;        return OrderResponse.fromOrder(order);&#10;    }&#10;&#10;    @Override&#10;    public OrderResponse modifyOrder(Long orderId, OrderRequest orderRequest, Long userId) {&#10;        Optional&lt;Order&gt; orderOpt = orderPort.findById(orderId);&#10;        if (orderOpt.isEmpty()) throw new IllegalArgumentException(&quot;Ordre non trouvé&quot;);&#10;        Order order = orderOpt.get();&#10;        // Vérification du verrouillage optimiste&#10;        Long versionBefore = order.getVersion();&#10;        if (Order.OrderStatus.FILLED.equals(order.getStatus()) || Order.OrderStatus.CANCELLED.equals(order.getStatus())) {&#10;            throw new IllegalStateException(&quot;Impossible de modifier un ordre rempli ou annulé&quot;);&#10;        }&#10;        // Contrôles pré-trade&#10;        PreTradeValidationPort.ValidationRequest validationRequest = new PreTradeValidationPort.ValidationRequest(&#10;            orderRequest.getSymbol(),&#10;            Order.Side.valueOf(orderRequest.getSide()),&#10;            Order.OrderType.valueOf(orderRequest.getType()),&#10;            orderRequest.getQuantity(),&#10;            orderRequest.getPrice(),&#10;            walletClient.getWallet(userId).getWallet()&#10;        );&#10;        PreTradeValidationPort.ValidationResult validation = preTradeValidationPort.validateOrder(validationRequest);&#10;        if (!validation.isValid()) {&#10;            order.setStatus(Order.OrderStatus.REJETE);&#10;            order.setRejectReason(validation.getRejectReason());&#10;            orderPort.save(order);&#10;            throw new IllegalStateException(&quot;Modification rejetée : &quot; + validation.getRejectReason());&#10;        }&#10;        // Appliquer les modifications&#10;        order.setQuantity(orderRequest.getQuantity());&#10;        order.setPrice(orderRequest.getPrice());&#10;        order.setType(Order.OrderType.valueOf(orderRequest.getType()));&#10;        order.setDuration(Order.DurationType.valueOf(orderRequest.getDuration()));&#10;        order.setTimestamp(Instant.now());&#10;        Order updatedOrder = orderPort.save(order);&#10;        // Vérification du verrouillage optimiste&#10;        if (!versionBefore.equals(updatedOrder.getVersion() - 1)) {&#10;            throw new RuntimeException(&quot;Conflit de version : l'ordre a été modifié par une autre transaction&quot;);&#10;        }&#10;        // Synchronisation avec le matching-service&#10;        OrderDTO orderDTO = new OrderDTO(&#10;            updatedOrder.getId(),&#10;            updatedOrder.getClientOrderId(),&#10;            updatedOrder.getUserId(),&#10;            updatedOrder.getSymbol(),&#10;            updatedOrder.getSide().name(),&#10;            updatedOrder.getType().name(),&#10;            updatedOrder.getQuantity(),&#10;            updatedOrder.getPrice(),&#10;            updatedOrder.getDuration().name(),&#10;            updatedOrder.getTimestamp(),&#10;            updatedOrder.getStatus().name(),&#10;            updatedOrder.getRejectReason()&#10;        );&#10;        try {&#10;            matchingClient.modifyOrder(orderDTO);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Erreur lors de la synchronisation avec le matching-service : {}&quot;, e.getMessage(), e);&#10;        }&#10;        return OrderResponse.fromOrder(updatedOrder);&#10;    }&#10;&#10;    public OrderResponse cancelOrder(Long orderId, Long userId) {&#10;        Optional&lt;Order&gt; orderOpt = orderPort.findById(orderId);&#10;        if (orderOpt.isEmpty()) throw new IllegalArgumentException(&quot;Ordre non trouvé&quot;);&#10;        Order order = orderOpt.get();&#10;        Long versionBefore = order.getVersion();&#10;        if (Order.OrderStatus.FILLED.equals(order.getStatus()) || Order.OrderStatus.CANCELLED.equals(order.getStatus())) {&#10;            throw new IllegalStateException(&quot;Impossible d'annuler un ordre rempli ou déjà annulé&quot;);&#10;        }&#10;        order.setStatus(Order.OrderStatus.CANCELLED);&#10;        order.setTimestamp(Instant.now());&#10;        Order updatedOrder = orderPort.save(order);&#10;        if (!versionBefore.equals(updatedOrder.getVersion() - 1)) {&#10;            throw new RuntimeException(&quot;Conflit de version : l'ordre a été modifié par une autre transaction&quot;);&#10;        }&#10;        // Synchronisation avec le matching-service&#10;        OrderDTO orderDTO = new OrderDTO(&#10;            updatedOrder.getId(),&#10;            updatedOrder.getClientOrderId(),&#10;            updatedOrder.getUserId(),&#10;            updatedOrder.getSymbol(),&#10;            updatedOrder.getSide().name(),&#10;            updatedOrder.getType().name(),&#10;            updatedOrder.getQuantity(),&#10;            updatedOrder.getPrice(),&#10;            updatedOrder.getDuration().name(),&#10;            updatedOrder.getTimestamp(),&#10;            updatedOrder.getStatus().name(),&#10;            updatedOrder.getRejectReason()&#10;        );&#10;        try {&#10;            matchingClient.cancelOrder(orderDTO);&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Erreur lors de la synchronisation avec le matching-service : {}&quot;, e.getMessage(), e);&#10;        }&#10;        return OrderResponse.fromOrder(updatedOrder);&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wallet-service/src/main/resources/db/migration/V3__rename_walletEntity_to_wallet.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wallet-service/src/main/resources/db/migration/V3__rename_walletEntity_to_wallet.sql" />
              <option name="updatedContent" value="ALTER TABLE walletEntity RENAME TO wallet;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wallet-service/src/main/resources/db/migration/V6__add_price_to_stock_rule.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wallet-service/src/main/resources/db/migration/V6__add_price_to_stock_rule.sql" />
              <option name="updatedContent" value="ALTER TABLE stock_rule ADD COLUMN price DECIMAL(18,2) NOT NULL DEFAULT 0;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>
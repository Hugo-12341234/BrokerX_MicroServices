<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/docs/architecture/arc42/arc42.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs/architecture/arc42/arc42.md" />
              <option name="originalContent" value="# 1. Introduction &amp; Objectifs&#10;&#10;## 1.1 Objectifs métier&#10;BrokerX est une plateforme de courtage en ligne, désormais migrée vers une architecture microservices (phase 2). Les utilisateurs peuvent s’inscrire, vérifier leur identité, s’authentifier avec MFA, déposer des fonds, placer des ordres et consulter leur portefeuille. L’objectif principal reste d’offrir une expérience sécurisée, fluide et conforme aux exigences réglementaires du secteur financier, tout en améliorant la performance, la disponibilité et la scalabilité grâce au découpage en services indépendants et à l’API Gateway.&#10;&#10;## 1.2 Fonctionnalités essentielles&#10;- Inscription et vérification d’identité (KYC)&#10;- Authentification forte avec MFA&#10;- Gestion du portefeuille virtuel (dépôt, solde)&#10;- Placement d’ordres d’achat et de vente&#10;- Gestion de l’idempotence et de la traçabilité des opérations&#10;- Journalisation des actions et audit de sécurité&#10;- Observabilité avancée (logs structurés, métriques Golden Signals)&#10;&#10;## 1.3 Objectifs de qualité pour l’architecture&#10;&#10;| Objectif de qualité | Scénario concret | Motivation |&#10;|---------------------|------------------|------------|&#10;| Sécurité | Un utilisateur ne peut accéder qu’à ses propres données et toutes les transactions sont chiffrées | Protection des données sensibles et conformité réglementaire |&#10;| Performance | Le système doit répondre à une requête d’ordre en moins de 250 ms (P95) et traiter au moins 800 ordres/s | Expérience utilisateur, compétitivité, passage à l’échelle microservices |&#10;| Disponibilité | Le service doit être disponible 95,5% du temps, même en cas de panne d’un composant | Continuité de service, fiabilité accrue par la résilience des microservices |&#10;| Résilience | En cas d’incident, le système doit pouvoir récupérer et restaurer les opérations sans perte de données | Robustesse et gestion proactive des erreurs |&#10;| Maintenabilité | Les évolutions fonctionnelles doivent pouvoir être réalisées rapidement et sans régression | Réduction des coûts de maintenance et adaptation aux besoins métier |&#10;| Scalabilité | Supporter la croissance du nombre d’utilisateurs et la montée en charge | Pérennité et adaptation à la demande |&#10;| Traçabilité &amp; auditabilité | Toutes les opérations sont journalisées et traçables | Conformité et sécurité |&#10;| Observabilité | Logs structurés et métriques (Golden Signals) accessibles pour le monitoring et l’optimisation | Pilotage de la performance et détection proactive des incidents |&#10;| Conformité | Respect des standards du secteur (tokens, MFA, KYC) | Obligations réglementaires |&#10;&#10;## 1.4 Parties prenantes&#10;&#10;| Partie prenante                  | Rôle                                   | Attente principale |&#10;|----------------------------------|----------------------------------------|--------------------|&#10;| Clients                         | Utilisateurs via interface web/mobile  | Expérience fluide, sécurité des transactions, accès rapide aux cotations et exécution des ordres |&#10;| Opérations Back-Office          | Gestion des règlements, supervision     | Outils de gestion efficaces, visibilité sur les opérations, fiabilité des processus |&#10;| Conformité / Risque             | Surveillance pré- et post-trade         | Accès aux journaux d’audit, alertes en cas d’anomalie, conformité réglementaire garantie |&#10;&#10;Cette section synthétise les besoins métier, techniques et réglementaires qui orientent toutes les décisions architecturales.&#10;&#10;## 1.5 Vue d’ensemble des exigences fonctionnelles&#10;&#10;| Cas d’utilisation | Description | Référence |&#10;|-------------------|-------------|-----------|&#10;| Inscription &amp; vérification d’identité | Permet à un utilisateur de créer un compte et de valider son identité via un processus KYC | UC01.md |&#10;| Authentification &amp; MFA | Permet à un utilisateur de s’authentifier avec mot de passe et code MFA | UC02.md |&#10;| Dépôt dans le portefeuille | Permet à un utilisateur de déposer des fonds dans son portefeuille virtuel | UC03.md |&#10;| Placement d’un ordre | Permet à un utilisateur de placer un ordre d’achat ou de vente sur un actif | UC05.md |&#10;| Appariement interne &amp; Exécution (matching) | Assure l’exécution automatique des ordres selon la priorité prix/temps, rapproche acheteurs et vendeurs, génère les transactions | UC07.md |&#10;| Consultation du portefeuille et des ordres | Permet à un utilisateur de consulter ses positions, ordres et historiques | UC07.md |&#10;&#10;## 1.6 Priorisation MoSCoW des cas d’utilisation&#10;&#10;# Priorisation MoSCoW des cas d'utilisation&#10;&#10;| Cas d'utilisation                                      | Priorité MoSCoW | Justification                                                                                   |&#10;|--------------------------------------------------------|-----------------|-----------------------------------------------------------------------------------------------------------|&#10;| UC-01 — Inscription &amp; Vérification d’identité          | Must            | Sans inscription et vérification, aucun utilisateur ne peut accéder à la plateforme ni respecter les exigences réglementaires (KYC/AML). C'est la base de toute relation de confiance et de conformité légale.|&#10;| UC-03 — Approvisionnement du portefeuille (dépôt virtuel)| Must            | Les utilisateurs doivent pouvoir disposer de liquidités pour effectuer des opérations : sans dépôt, aucune transaction n'est possible, ce qui bloque toute activité sur la plateforme. |&#10;| UC-05 — Placement d’un ordre (marché/limite) avec contrôles pré-trade | Must            | Le placement d'ordre est le cœur du métier : sans cette fonctionnalité, la plateforme ne répond à aucun besoin de courtage et perd toute valeur pour les clients.  |&#10;| UC-02 — Authentification &amp; MFA                         | Must            | La sécurité des accès est indispensable pour la conformité et la confiance : une authentification forte est requise pour garantir la sécurité des comptes et la conformité réglementaire. |&#10;| UC-07 — Appariement interne &amp; Exécution (matching)     | Must            | L'appariement automatique est essentiel pour assurer l'exécution des ordres selon les règles de priorité prix/temps : sans cette mécanique, la plateforme ne peut traiter les transactions de manière fiable et conforme aux standards du secteur. |&#10;| UC-04 — Abonnement aux données de marché               | Should          | Permet aux utilisateurs de prendre des décisions informées, mais la plateforme peut fonctionner sans cette fonctionnalité, en mode minimal ou pour des tests.|&#10;| UC-06 — Modification / Annulation d’un ordre           | Could           | Offre de la flexibilité et réduit les erreurs, mais un MVP peut fonctionner sans cette capacité, en imposant plus de rigueur à l'utilisateur.|&#10;| UC-08 — Confirmation d’exécution &amp; Notifications       | Won't Have      | Utile pour la transparence et l'information client, mais sera exclu de la première version pour se concentrer sur les fonctionnalités essentielles et réduire la complexité technique.|&#10;&#10;&gt; Cette priorisation MoSCoW garantit que les fonctionnalités critiques (Must) sont livrées en priorité pour assurer la valeur métier, la conformité et la sécurité, tandis que les autres (Should/Could) enrichissent l'expérience ou optimisent le service. Les éléments en Won't Have sont explicitement exclus pour permettre une livraison rapide et maîtrisée du périmètre minimal.&#10;&#10;## 1.7 Description détaillée des cas d’utilisation&#10;&#10;### UC-01 — Inscription &amp; Vérification d’identité&#10;&#10;Objectif:&#10;Faciliter l’enregistrement d’un nouvel utilisateur sur la plateforme BrokerX en recueillant ses informations personnelles, en procédant à la vérification réglementaire de son identité (KYC/AML) et en activant son accès. Ce processus initie la relation de confiance entre l’utilisateur et BrokerX.&#10;&#10;Acteur principal:&#10;Client&#10;&#10;Déclencheur:&#10;Le Client souhaite créer un compte pour s'inscrire à la plateforme.&#10;&#10;Pré-conditions:&#10;Aucune.&#10;&#10;Postconditions (succès):&#10;- Un compte utilisateur est créé avec le statut &quot;PENDING&quot;.&#10;- Après la vérification d'identité, le compte passe au statut &quot;ACTIVE&quot;.&#10;&#10;Postconditions (échec):&#10;- Le compte n’est pas créé ou est marqué &quot;REJECTED&quot; avec une raison précisée.&#10;&#10;Flux principal&#10;1. Le Client fournit son email, un mot de passe et les données personnelles requises (nom, adresse, date de naissance).&#10;2. Le Système vérifie la validité des informations et crée un compte avec le statut &quot;PENDING&quot;.&#10;3. Le Système envoie un lien de vérification d’identité par email.&#10;4. Le Client reçoit un lien OTP (one-time passwords) et confirme son identité en cliquant sur le lien.&#10;5. Le Système change le statut du compte à &quot;ACTIVE&quot; et journalise l’opération (horodatage, adresse IP, identifiant).&#10;&#10;Alternatifs / Exceptions&#10;- A1. Vérification d'identité non complétée : Le compte reste avec le statut &quot;PENDING&quot;. Le lien de vérification expire après 1 jour.&#10;- E1. Email déjà utilisé : L'opération d'inscription de l'utilisateur est rejetée. On lui propose d'aller faire un login à la place.&#10;- E2. Informations invalides (email du mauvais format) : Le Système rejette l'inscription et demande au Client de corriger les informations.&#10;&#10;Critère d’acceptation:&#10;Un utilisateur fournit des informations valides, reçoit le lien de vérification, confirme son identité, et son compte passe au statut &quot;ACTIVE&quot;.&#10;&#10;### UC-02 — Authentification &amp; MFA&#10;&#10;Objectif:&#10;Assurer la sécurité d’accès à la plateforme BrokerX en permettant aux clients de s’authentifier via identifiant/mot de passe et un code multi-facteurs (OTP), afin de protéger les comptes contre toute tentative d’accès non autorisée.&#10;&#10;Acteur principal:&#10;Client&#10;&#10;Déclencheur:&#10;Le Client souhaite se connecter à la plateforme.&#10;&#10;Pré-conditions:&#10;Le compte du Client doit être au statut &quot;ACTIVE&quot;.&#10;&#10;Postconditions (succès):&#10;- Une session valide est établie pour le client (token de session).&#10;- Le rôle de &quot;Client&quot; est associé à la session.&#10;&#10;Postconditions (échec):&#10;- Aucune session n’est créée.&#10;- Le Client ne peut pas accéder à la plateforme.&#10;&#10;Flux principal&#10;1. Le Client saisit son identifiant et son mot de passe.&#10;2. Le Système vérifie l’état du compte ainsi que les informations entrées par le client.&#10;3. Le Système envoit un code temporaire à l'utilisation par email.&#10;4. Le Client saisit le code MFA reçu.&#10;5. Le Système valide le code entré, génère le token de session et journalise l’audit (IP, device, horodatage).&#10;&#10;Alternatifs / Exceptions&#10;- E1. Challenge MFA expiré : Si le code MFA n’est pas saisi dans le délai imparti, l’authentification échoue et le Client doit recommencer.&#10;- E2. Challenge MFA déjà utilisé : Si le code MFA a déjà été utilisé, l’authentification échoue et un nouveau challenge doit être généré.&#10;- E3. Échec MFA (3 tentatives) : Après 3 échecs de saisie du code MFA, l'utilisateur est verrouillé pendant 30 secondes et il doit attendre avant de réessayer.&#10;- E4. Compte suspendu : Si le Client rate une 4e fois, son compte est suspendu et il doit contacter le support.&#10;- E5. Compte non actif : Si le compte n’est pas au statut &quot;ACTIVE&quot;, l’authentification est rejetée avec une raison précisée.&#10;&#10;Critère d’acceptation:&#10;Un client saisit ses identifiants valides, reçoit le code MFA, le saisit correctement, et accède à la plateforme avec une session active.&#10;&#10;### UC-03 — Approvisionnement du portefeuille (dépôt virtuel)&#10;&#10;Objectif:&#10;Permettre aux utilisateurs d’augmenter le solde de leur portefeuille virtuel en réalisant des dépôts simulés, afin de garantir la disponibilité des fonds nécessaires pour placer des ordres d’achat sur la plateforme BrokerX.&#10;&#10;Acteur principal:&#10;Client&#10;&#10;Acteurs secondaires:&#10;Service Paiement Simulé&#10;&#10;Déclencheur:&#10;Le Client crédite son solde en monnaie fiduciaire simulée.&#10;&#10;Pré-conditions:&#10;Le compte du Client doit être au statut &quot;ACTIVE&quot;.&#10;&#10;Postconditions (succès):&#10;- Le solde du portefeuille est augmenté.&#10;- Une écriture précise de la transaction effectuée est ajoutée au journal.&#10;&#10;Postconditions (échec):&#10;- Le solde du portefeuille reste inchangé.&#10;- Une écriture d’erreur est ajoutée au journal avec le motif de l’échec.&#10;&#10;Flux principal&#10;1. Le Client saisit le montant à déposer.&#10;2. Le Système vérifie les limites (montant minimum/maximum).&#10;3. Le Système crée une transaction avec le statut &quot;PENDING&quot;.&#10;4. Le Service Paiement Simulé traite la demande et répond &quot;SETTLED&quot;.&#10;5. Le Système crédite le portefeuille, journalise la transaction et notifie le Client du résultat de l'opération.&#10;&#10;Alternatifs / Exceptions:&#10;- E1. Paiement rejeté : La transaction passe au statut &quot;FAILED&quot; et le Client reçoit une notification avec le motif du rejet.&#10;- E2. Idempotence : Si une demande de dépôt avec la même idempotency-key, le Système renvoie le résultat précédent.&#10;- E3. Montant hors limites : Si le montant est inférieur au minimum ou supérieur au maximum autorisé, le dépôt est refusé et le Client est informé.&#10;- E4. Compte non trouvé ou non actif : Si le compte n’existe pas ou n’est pas au statut &quot;ACTIVE&quot;, le dépôt est refusé.&#10;&#10;Critère d’acceptation&#10;Un client saisit un montant valide, la transaction est acceptée, le portefeuille est crédité, et la transaction est journalisée avec succès.&#10;&#10;### UC-05 — Placement d’un ordre (marché/limite) avec contrôles pré-trade&#10;&#10;Objectif:&#10;Offrir aux clients la possibilité de soumettre des ordres d’achat ou de vente (marché ou limite), soumis à des contrôles pré-trade automatisés, afin d’assurer la conformité et la sécurité des opérations sur BrokerX.&#10;&#10;Acteur principal:&#10;Client&#10;&#10;Acteurs secondaires:&#10;Moteur de Règles Pré-trade, Comptes/Portefeuilles&#10;&#10;Déclencheur:&#10;Le Client soumet un ordre.&#10;&#10;Pré-conditions:&#10;Session valide, portefeuille existant.&#10;&#10;Postconditions (succès):&#10;- Ordre accepté et placé dans le carnet interne.&#10;&#10;Postconditions (échec):&#10;- Ordre rejeté avec raison.&#10;&#10;Flux principal&#10;1. Le Client entre le symbole, le sens (ACHAT/VENTE), le type (MARCHE/LIMITE), la quantité, le prix (si limite) et la durée (DAY/IOC/FOK).&#10;2. Le Système normalise les données et horodate l’opération (timestamp système en UTC avec millisecondes).&#10;3. Le Système effectue les contrôles pré-trade :&#10;   - Pouvoir d’achat et marge disponible&#10;   - Règles de prix (bandes, tick size)&#10;   - Interdictions (short-sell n'est pas autorisé)&#10;   - Limites par utilisateur (taille maximales d’ordre)&#10;   - Vérifications de cohérence (quantité &gt; 0)&#10;4. Si tous les contrôles sont validés, le Système attribue un clientOrderId et persiste l’ordre.&#10;&#10;Alternatifs / Exceptions:&#10;- A1. Type Marché : Le prix n’est pas requis, routage immédiat.&#10;- E1. Pouvoir d’achat insuffisant : L’ordre est rejeté avec le motif correspondant.&#10;- E2. Violation bande de prix : L’ordre est rejeté avec le motif correspondant.&#10;- E3. Idempotence : Si un ordre avec le même clientOrderId est reçu, le Système renvoie le résultat précédent.&#10;- E4. Prix limite absent pour ordre limite : L'ordre n'est pas effectué et le Client est informé.&#10;- E5. Quantité non positive : L’ordre n'est pas effectué et le Client est informé.&#10;- E6. Short-sell non autorisé : L’ordre est rejeté avec le motif correspondant.&#10;- E7. Tick size non respecté : L’ordre est rejeté si le prix ne respecte pas l’incrément minimal autorisé.&#10;- E8. Taille maximale d’ordre dépassée : L’ordre est rejeté si la quantité dépasse la limite autorisée pour l’utilisateur.&#10;&#10;Critère d’acceptation:&#10;Un client soumet un ordre valide pour le stock &quot;TEST&quot;, tous les contrôles pré-trade sont passés, l’ordre est accepté et enregistré dans le carnet interne.&#10;&#10;### UC-07 — Appariement interne &amp; Exécution (matching)&#10;&#10;Objectif:&#10;Assurer l’exécution automatique des ordres en interne selon les règles de priorité (prix/temps) en rapprochant acheteurs et vendeurs. Ce cas fournit la mécanique centrale de traitement des transactions sur la plateforme.&#10;&#10;Acteur principal:&#10;Moteur d’appariement interne&#10;&#10;Acteurs secondaires:&#10;Données de Marché, Portefeuilles&#10;&#10;Déclencheur:&#10;Nouvel ordre arrive dans le carnet.&#10;&#10;Pré-conditions:&#10;Carnet maintenu (prix/temps), règles de priorité définies.&#10;&#10;Postconditions (succès):&#10;- Transactions générées (partielles possibles), état d’ordre mis à jour.&#10;&#10;Postconditions (échec):&#10;- Ordre reste Working (pas de contrepartie).&#10;&#10;Flux principal&#10;1. Le Moteur insère l’ordre dans le carnet (Buy/Sell).&#10;2. Il recherche la meilleure contrepartie (price-time priority).&#10;3. Si match, crée une ou plusieurs exécutions (fills), met à jour quantités.&#10;4. Émet événements ExecutionReport (Fill/Partial Fill).&#10;5. Met à jour top-of-book, publie update marché.&#10;&#10;Alternatifs / Exceptions:&#10;- A1. IOC/FOK : IOC exécute le possible puis annule le reste; FOK exécute tout sinon annule.&#10;&#10;Critère d’acceptation:&#10;Un ordre d’achat de 10 actions AAPL à 100 $ rencontre un ordre de vente identique. Résultat attendu : une transaction est générée, les quantités sont ajustées et un rapport d’exécution (Execution Report) est publié.&#10;&#10;## 2. Contraintes d’architecture&#10;&#10;### 2.1 Contraintes techniques&#10;&#10;| Contrainte | Explication |&#10;|------------|------------|&#10;| Monolithe Java/Spring Boot | L’application doit être développée en Java avec le framework Spring Boot, sous forme de monolithe. |&#10;| Base de données PostgreSQL | Toutes les données persistantes doivent être stockées dans une base PostgreSQL. |&#10;| Authentification MFA | L’authentification multi-facteurs est obligatoire pour tous les accès utilisateurs. |&#10;| Docker &amp; Docker Compose | Le déploiement doit se faire via des conteneurs Docker, orchestrés avec Docker Compose. |&#10;| API REST | Les interfaces externes doivent être exposées sous forme d’API REST. |&#10;| Journalisation et audit | Toutes les opérations critiques, y compris les événements d’exécution (fills, partial fills, ExecutionReport), doivent être journalisées pour audit et traçabilité. |&#10;| Caching | Un mécanisme de cache (local ou distribué) doit être utilisé pour optimiser la consultation du carnet d’ordres, du top-of-book et la diffusion des données de marché, afin d’améliorer la performance et limiter la charge sur la base de données. |&#10;| Observabilité | Le système doit fournir des logs structurés, des métriques (Golden Signals) et des traces pour le moteur d’appariement et l’exécution des ordres, afin d’assurer le suivi, la détection des anomalies et la conformité. |&#10;&#10;### 2.2 Contraintes réglementaires et de conformité&#10;&#10;| Contrainte | Explication |&#10;|------------|------------|&#10;| KYC (Know Your Customer) | La vérification d’identité est obligatoire pour chaque utilisateur avant toute opération. |&#10;| Sécurité des données | Chiffrement des données sensibles et respect des standards du secteur financier. |&#10;| Traçabilité | Toutes les actions doivent être traçables et accessibles pour audit. |&#10;&#10;### 2.3 Contraintes organisationnelles&#10;&#10;| Contrainte | Explication |&#10;|------------|------------|&#10;| CI/CD | Les livraisons doivent passer par un pipeline d’intégration et de déploiement continu. |&#10;| Documentation | Toute nouvelle fonctionnalité doit être documentée selon les standards internes. |&#10;| Tests automatisés | Les fonctionnalités critiques, dont le moteur d’appariement interne (matching), doivent être couvertes par des tests automatisés (unitaires, d’intégration et E2E). |&#10;&#10;### 2.4 Contraintes de gestion et maintenance&#10;&#10;| Contrainte | Explication |&#10;|------------|------------|&#10;| Maintenabilité | Le code doit être structuré pour faciliter les évolutions et la correction des bugs. |&#10;| Monitoring | Des outils de monitoring doivent être mis en place pour suivre la santé du système, en particulier le moteur d’appariement : détection des incohérences du carnet, alertes et gestion des rollbacks segmentaires. L’observabilité doit permettre un suivi en temps réel des transactions et du matching. |&#10;&#10;Ces contraintes doivent être respectées tout au long du cycle de vie du projet et orientent toutes les décisions architecturales et techniques.&#10;&#10;## 3. Portée du système et contexte&#10;&#10;### 3.1 Contexte métier&#10;&#10;Le tableau ci-dessous présente les principaux acteurs et leurs interactions, en cohérence avec le diagramme de contexte DDD (voir section 3.2).&#10;&#10;| Acteur / Système         | Interagit avec         | Flux / Description                                                                                 |&#10;|--------------------------|------------------------|---------------------------------------------------------------------------------------------------|&#10;| Client                   | Application BrokerX    | S'inscrit, s'authentifie, effectue des opérations de courtage                                     |&#10;| Application BrokerX      | Service d'Email        | Demande l'envoi de courriels (vérification, MFA, notifications) au Service d'Email                |&#10;| Service d'Email          | Client                 | Envoie les courriels (liens de vérification, codes MFA, notifications) au Client                  |&#10;&#10;### 3.2 Diagramme de contexte DDD&#10;&#10;Le diagramme de contexte ci-dessous illustre les frontières du système BrokerX, ses principaux partenaires externes et les interactions majeures du point de vue métier et DDD.&#10;&#10;![Diagramme de contexte DDD](docs/ddd/diagrammeDeContexte/diagrammeDeContexte.png)&#10;&#10;### 3.3 Diagramme des bounded contexts&#10;&#10;Le diagramme des bounded contexts présente la découpe du domaine BrokerX en sous-domaines fonctionnels cohérents (bounded contexts), chacun représentant une zone de responsabilité métier distincte. Cette vue permet de visualiser les interactions et les frontières entre les différents contextes métier.&#10;&#10;![Diagramme des bounded contexts](docs/ddd/boundedContexts/bounded_contexts.png)&#10;&#10;### 3.4 Contexte technique&#10;&#10;Le diagramme de déploiement ci-dessous illustre l’infrastructure technique et les canaux présentement utilisés par BrokerX.&#10;&#10;![Diagramme de déploiement BrokerX](docs/architecture/4+1/deploymentView/deploymentDiagram.png)&#10;&#10;| Système technique externe         | Canal / Protocole | Format des données | Sécurité | Explication interface |&#10;|-----------------------------------|-------------------|--------------------|----------|----------------------|&#10;| Clients                          | API REST (HTTPS)  | JSON               | MFA, chiffrement TLS | Accès utilisateur, ordres, notifications, cotations temps réel |&#10;| SMTP Provider (GMail)             | SMTP (TLS)        | Texte, HTML        | Chiffrement TLS, authentification SMTP | Envoi d’e-mails pour notifications, vérification d’adresse, récupération de mot de passe |&#10;&#10;Chaque interface technique est sécurisée par chiffrement TLS et, selon le cas, par authentification forte (MFA, tokens, SMTP login). Les explications précisent le rôle et les exigences de chaque interface.&#10;&#10;## 4. Stratégie de solution&#10;&#10;L’architecture de BrokerX repose désormais sur une approche microservices, chaque domaine métier étant isolé dans un service indépendant (auth-service, api-gateway, matching-service, order-service, wallet-service, etc.). Cette stratégie permet une évolutivité, une résilience et une flexibilité accrues, tout en facilitant la maintenance et le déploiement.&#10;&#10;Chaque microservice est développé principalement en Java avec Spring Boot, et expose ses fonctionnalités via des API REST sécurisées (HTTPS/JSON). L’api-gateway centralise l’accès aux services, gère le routage, l’authentification et la sécurité des échanges. Un load balancer avec NGINX est installé entre le gateway et les microservices, afin de pouvoir créer plusieurs instances de certains microservices. Ceci permet une bonne scalabilité et une tolérance aux pannes. Les communications inter-services se font principalement par API REST, mais peuvent évoluer vers des solutions de messaging (ex : Kafka, RabbitMQ) pour les besoins d’asynchronisme ou de scalabilité.&#10;&#10;La persistance des données est gérée de façon indépendante : chaque microservice possède sa propre base de données (PostgreSQL), ce qui garantit l’isolation des données, la conformité aux principes DDD et la robustesse des transactions critiques. Cette séparation permet d’éviter les dépendances fortes et facilite l’évolution de chaque service.&#10;&#10;La sécurité est centralisée via l’auth-service, qui gère l’authentification forte (MFA), la gestion des rôles et la journalisation des actions critiques. Les exigences réglementaires (KYC, RGPD) sont respectées grâce à une gestion fine des accès et à la traçabilité des opérations sensibles.&#10;&#10;Le déploiement et l’orchestration des services sont assurés par Docker et Docker Compose, permettant de gérer facilement les environnements, la scalabilité et la portabilité. Chaque service peut être déployé, mis à jour ou redémarré indépendamment, ce qui réduit les risques et accélère les cycles de livraison.&#10;&#10;Un pipeline CI/CD adapté aux microservices automatise les tests (unitaires, d’intégration, E2E) et les livraisons pour chaque service, garantissant la qualité et la rapidité des mises en production. Les tests sont systématisés pour détecter rapidement les régressions et assurer la fiabilité du système global.&#10;&#10;La documentation des API et des services est produite en continu, facilitant l’intégration de nouveaux membres et l’évolution du système. L’utilisation de standards ouverts (OpenAPI/Swagger) permet de garder une trace claire des interfaces et des contrats entre services.&#10;&#10;Ce choix d’architecture microservices, associé à des technologies éprouvées et à des processus automatisés, permet de répondre efficacement aux objectifs de sécurité, performance, disponibilité et conformité, tout en gardant la solution évolutive pour de futurs besoins. Cette stratégie assure un socle solide pour BrokerX et prépare l’ouverture vers des intégrations ou des évolutions plus complexes.&#10;&#10;## 5. Vue des blocs de construction&#10;&#10;### 5.1 Introduction&#10;Cette section présente la structure statique de BrokerX selon deux niveaux de précision : un premier niveau très high level (système vu comme un bloc, interfaces externes), puis un second niveau qui détaille les principaux composants internes.&#10;&#10;### 5.2 Vue d’ensemble high level (Niveau 1)&#10;![Diagramme high level](./BB_1.png)&#10;Le diagramme ci-dessus illustre les principaux éléments et interactions du système BrokerX :&#10;&#10;| Élément                       | Type / Technologie                       | Rôle / Description                                                                                                                        |&#10;|-------------------------------|------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------|&#10;| Utilisateur                   | Acteur externe                           | Interagit avec BrokerX via l’interface web : navigation, formulaires, requêtes REST, réception d’e-mails                                  |&#10;| API Gateway                   | Service dédié (Spring Cloud Gateway, etc.)| Point d’entrée unique : centralise l’accès, la sécurité et le routage des requêtes vers le load balancer                                  |&#10;| Load Balancer                 | NGINX / Traefik                          | Répartit la charge entre les instances des microservices, assure la haute disponibilité et la résilience du système                       |&#10;| auth-service                  | Microservice Java/Spring Boot             | Gère l’authentification, MFA, gestion des rôles, journalisation des actions critiques                                                     |&#10;| matching-service              | Microservice Java/Spring Boot             | Appariement des ordres selon les règles métier, gestion du carnet d’ordres                                                                |&#10;| order-service                 | Microservice Java/Spring Boot             | Gestion des ordres de trading, validation pré-trade, traçabilité des opérations                                                           |&#10;| wallet-service                | Microservice Java/Spring Boot             | Gestion du portefeuille virtuel, dépôts, solde, transactions                                                                             |&#10;| DB Auth                       | PostgreSQL                               | Stocke les données d’authentification, MFA, rôles                                                                                        |&#10;| DB Matching                   | PostgreSQL                               | Stocke les données d’appariement, carnet d’ordres                                                                                        |&#10;| DB Order                      | PostgreSQL                               | Stocke les ordres, statuts, logs d’exécution                                                                                             |&#10;| DB Wallet                     | PostgreSQL                               | Stocke les portefeuilles, transactions, historiques                                                                                      |&#10;| Système Email (SMTP)          | Service externe                          | Reçoit les demandes d’envoi d’e-mails (liens de vérification, codes MFA) et transmet les courriels à l’utilisateur                       |&#10;&#10;**Principales interactions :**&#10;- L’utilisateur accède à BrokerX via l’API Gateway, qui centralise l’accès, la sécurité et le routage des requêtes&#10;- L’API Gateway route les requêtes vers le load balancer, qui répartit la charge vers les microservices&#10;- Chaque microservice gère un domaine métier spécifique et possède sa propre base PostgreSQL&#10;- Les microservices communiquent avec le système email (SMTP) pour l’envoi de codes MFA et de notifications&#10;- Le système email transmet les e-mails de vérification et de codes à l’utilisateur&#10;&#10;**Données stockées dans les bases :**&#10;- Auth-service : utilisateurs, MFA, rôles&#10;- Matching-service : carnet d’ordres, appariements&#10;- Order-service : ordres, statuts, logs d’exécution&#10;- Wallet-service : portefeuilles, transactions&#10;&#10;Cette vue permet de comprendre la structure globale du système, les principaux composants et leurs interactions, ainsi que la répartition des responsabilités entre les microservices.&#10;&#10;### 5.3 Vue interne des composants (Niveau 2)&#10;![Diagramme de composants](./BB_2.png)&#10;&#10;Le diagramme ci-dessus détaille l’architecture interne du système BrokerX, organisée en microservices :&#10;&#10;| Composant                      | Type / Rôle                                      | Description                                                                 |&#10;|--------------------------------|--------------------------------------------------|-----------------------------------------------------------------------------|&#10;| Utilisateur (Frontend React)   | Acteur externe                                   | Accède à l’application web pour toutes les opérations de courtage           |&#10;| API Gateway                    | Proxy/Routage                                    | Point d’entrée unique, route les requêtes vers les microservices            |&#10;| Load Balancer (NGINX)          | Répartition de charge / proxy                    | Distribue les requêtes vers les instances des microservices, config nginx.conf|&#10;| AuthController                 | Contrôleur (auth-service)                        | Gère l’authentification et la vérification MFA                              |&#10;| UserVerificationController     | Contrôleur (auth-service)                        | Gère la vérification d’identité (KYC)                                       |&#10;| OrderController                | Contrôleur (order-service)                       | Permet de passer et consulter des ordres de trading                         |&#10;| WalletController               | Contrôleur (wallet-service)                      | Gère le portefeuille et les dépôts                                          |&#10;| MatchingController             | Contrôleur (matching-service)                    | Gère le matching des ordres                                                 |&#10;| AuthenticationService          | Service métier (auth-service)                    | Logique d’authentification et MFA                                           |&#10;| RegistrationService            | Service métier (auth-service)                    | Gère l’inscription et la vérification utilisateur                           |&#10;| OrderService                   | Service métier (order-service)                   | Logique métier pour la gestion des ordres                                   |&#10;| PreTradeValidationService      | Service métier (order-service)                   | Valide les ordres avant exécution                                           |&#10;| StockService                   | Service métier (order-service)                   | Gestion des actifs financiers et cotations                                   |&#10;| WalletDepositService           | Service métier (wallet-service)                  | Gère les dépôts dans le portefeuille                                        |&#10;| MatchingService                | Service métier (matching-service)                | Logique de matching d’ordres                                                |&#10;| DB Auth (PostgreSQL)           | Base de données dédiée                           | Stocke les données d’authentification et utilisateurs                       |&#10;| DB Order (PostgreSQL)          | Base de données dédiée                           | Stocke les ordres et historiques de trading                                 |&#10;| DB Wallet (PostgreSQL)         | Base de données dédiée                           | Stocke les informations de portefeuille                                     |&#10;| DB Matching (PostgreSQL)       | Base de données dédiée                           | Stocke les données de matching                                              |&#10;| Système Email (SMTP)           | Service externe                                  | Envoie les notifications et codes MFA aux utilisateurs                      |&#10;&#10;**Principales interactions :**&#10;- L’utilisateur interagit avec le Frontend React, qui transmet les requêtes à l’API Gateway.&#10;- L’API Gateway centralise et sécurise l’accès, puis transmet les requêtes au Load Balancer (NGINX).&#10;- Le Load Balancer distribue les requêtes vers les microservices appropriés (auth-service, order-service, wallet-service, matching-service).&#10;- Chaque microservice possède ses propres contrôleurs et services métier, ainsi qu’une base de données dédiée.&#10;- Les services d’inscription et d’authentification envoient des e-mails (liens de vérification, codes MFA) au système SMTP, qui transmet ces messages à l’utilisateur.&#10;&#10;Cette vue permet de comprendre la répartition des responsabilités, les flux d’information et la collaboration entre les composants, tout en respectant l’architecture microservices et le routage via API Gateway et NGINX.&#10;&#10;### 5.4 Organisation du code et conventions&#10;Le code de chacun des microservices est structuré selon une approche hexagonale : les &quot;adapters&quot; gèrent les interactions externes (web, persistence), le &quot;domain&quot; regroupe la logique métier et les modèles, et &quot;infrastructure&quot; contient la configuration technique. Les conventions de nommage (camelCase) et de structure facilitent l’extension et la maintenance du projet. Les tests automatisés couvrent les fonctionnalités critiques, et la documentation est maintenue à jour pour chaque évolution majeure.&#10;&#10;## 6. Vue d’ensemble des scénarios&#10;&#10;### Diagramme&#10;- ![Diagramme de cas d’utilisation](docs/architecture/4+1/scenarios/useCaseDiagram.png)&#10;&#10;### Contexte&#10;La vue scénarios expose les principaux cas d’utilisation du système BrokerX, tels qu’ils sont vécus par les utilisateurs et les systèmes externes. Elle permet de visualiser les interactions entre le client et l’application, ainsi que les dépendances fonctionnelles entre les différents UC.&#10;&#10;### Éléments&#10;- Acteurs externes : Client (utilisateur principal), Service Paiement Simulé (pour le dépôt), Moteur d’appariement interne (matching), Données de Marché&#10;- Cas d’utilisation : Inscription &amp; vérification d’identité, Authentification &amp; MFA, Dépôt dans le portefeuille, Placement d’un ordre, Appariement interne &amp; Exécution (matching)&#10;&#10;### Relations&#10;- Le client peut initier chacun des cas d’utilisation principaux, sauf l'appariement interne qui est enclenché par le moteur d’appariement interne&#10;- Le dépôt utilise le service de paiement simulé&#10;- Le placement d’un ordre dépend du solde du portefeuille&#10;- Le placement d’un ordre déclenche le cas d’utilisation d’appariement interne &amp; exécution&#10;- L’appariement interne &amp; exécution est réalisé par le moteur d’appariement et utilise les données de marché&#10;&#10;### Rationnel&#10;Cette vue permet de relier les besoins métier aux fonctionnalités du système, de valider la couverture fonctionnelle et d’illustrer les interactions principales, y compris le nouveau processus d’appariement et d’exécution des ordres. L’ajout du cas UC-07 assure que la mécanique centrale de traitement des transactions (matching) est bien couverte, avec la gestion des priorités prix/temps, la génération des transactions et la mise à jour des états d’ordre et des portefeuilles. Les acteurs externes (moteur d’appariement, données de marché, portefeuilles) sont explicitement intégrés pour refléter la réalité technique et métier de la plateforme BrokerX. Cette vue garantit que l’architecture répond bien aux attentes des utilisateurs et des parties prenantes, tout en facilitant la communication entre les équipes métier et technique et en identifiant les scénarios critiques à tester, notamment ceux liés à l’exécution automatique des ordres.&#10;&#10;&#10;## 7. Vue de déploiement&#10;&#10;Le diagramme ci-dessous illustre l’infrastructure technique et la distribution des principaux artefacts du système BrokerX dans une architecture microservices :&#10;&#10;![Diagramme de déploiement BrokerX](docs/architecture/4+1/deploymentView/deploymentDiagram.png)&#10;&#10;| Nœud / Composant                      | Type / Technologie         | Canal / Protocole      | Sécurité / Persistance         | Explication technique                                                                 |&#10;|---------------------------------------|----------------------------|------------------------|-------------------------------|--------------------------------------------------------------------------------------|&#10;| Utilisateur                          | Acteur externe             | -                      | -                             | Interagit via le navigateur web                                                      |&#10;| Frontend (React)                     | Application web            | HTTPS/HTTP 8090        | TLS                           | Interface utilisateur, communique avec l’API Gateway                                 |&#10;| API Gateway                          | Microservice Java/Spring   | HTTPS/HTTP 8080        | TLS, routage                  | Point d’entrée unique, centralise la sécurité et le routage vers les microservices   |&#10;| Load Balancer (NGINX)                | Proxy/Routage              | Interne Docker         | TLS, config nginx.conf         | Répartit la charge entre les microservices, assure la haute disponibilité            |&#10;| auth-service                         | Microservice Java/Spring   | Interne Docker         | TLS, MFA, DB dédiée           | Gère l’authentification, MFA, gestion des rôles, journalisation                      |&#10;| order-service                        | Microservice Java/Spring   | Interne Docker         | TLS, DB dédiée                | Gestion des ordres de trading, validation pré-trade, traçabilité                     |&#10;| wallet-service                       | Microservice Java/Spring   | Interne Docker         | TLS, DB dédiée                | Gestion du portefeuille virtuel, dépôts, solde, transactions                         |&#10;| matching-service                     | Microservice Java/Spring   | Interne Docker         | TLS, DB dédiée                | Appariement des ordres, gestion du carnet d’ordres                                   |&#10;| DB Auth                              | PostgreSQL                 | JDBC 5432              | Authentification, persistance | Stocke les données d’authentification, MFA, rôles                                    |&#10;| DB Order                             | PostgreSQL                 | JDBC 5432              | Persistance                    | Stocke les ordres, statuts, logs d’exécution                                         |&#10;| DB Wallet                            | PostgreSQL                 | JDBC 5432              | Persistance                    | Stocke les portefeuilles, transactions, historiques                                  |&#10;| DB Matching                          | PostgreSQL                 | JDBC 5432              | Persistance                    | Stocke les données d’appariement, carnet d’ordres                                    |&#10;| Volume: postgres_data                | Volume Docker              | Interne Docker         | Persistance                    | Persistance des données PostgreSQL                                                    |&#10;| SMTP Provider (Gmail, Outlook...)    | Service externe (SMTP)     | SMTP 587               | TLS, authentification         | Envoi d’e-mails (notifications, vérification, récupération)                          |&#10;&#10;### Contexte&#10;La vue déploiement décrit l’architecture physique du système : chaque microservice est déployé dans son propre conteneur Docker, tous connectés au même réseau Docker interne (brokerx-network). Le frontend (React) communique avec l’API Gateway, qui centralise la sécurité et le routage. L’API Gateway transmet les requêtes au load balancer (NGINX), qui répartit la charge vers les microservices métier (auth, order, wallet, matching). Chaque microservice possède sa propre base PostgreSQL pour garantir l’isolation des données et la robustesse des transactions. Les volumes Docker assurent la persistance des données, même lors des mises à jour ou redémarrages. Le service SMTP externe gère l’envoi des notifications et des codes MFA. Cette architecture permet une scalabilité horizontale, une haute disponibilité et une maintenance facilitée, chaque service pouvant être mis à jour ou redémarré indépendamment.&#10;&#10;### Éléments&#10;- Conteneurs Docker pour chaque microservice (auth-service, order-service, wallet-service, matching-service, api-gateway, frontend)&#10;- Load Balancer (NGINX) pour la répartition de charge&#10;- Réseau Docker interne (brokerx-network) pour la communication sécurisée&#10;- Bases PostgreSQL dédiées pour chaque microservice&#10;- Volume Docker pour la persistance des données&#10;- Service SMTP externe pour l’envoi d’e-mails&#10;&#10;### Relations&#10;- Le frontend communique avec l’API Gateway via HTTPS&#10;- L’API Gateway transmet les requêtes au load balancer NGINX&#10;- NGINX répartit la charge vers les microservices métier&#10;- Chaque microservice accède à sa propre base PostgreSQL&#10;- Les volumes Docker assurent la persistance des données&#10;- Les microservices communiquent avec le service SMTP pour l’envoi d’e-mails&#10;&#10;### Rationnel&#10;Cette vue permet de comprendre la topologie du système BrokerX dans une architecture microservices : chaque service est isolé, scalable et maintenable indépendamment. Le réseau Docker interne garantit la sécurité et la rapidité des communications. La séparation des bases de données assure la conformité, la robustesse et la traçabilité des opérations. Le load balancer et l’API Gateway centralisent le routage et la sécurité, tandis que le service SMTP gère les notifications critiques. Cette organisation facilite la supervision, la gestion des incidents et l’évolution de l’architecture technique.&#10;&#10;## 8. Vue Logique&#10;&#10;### Diagrammes de classes par microservice&#10;- Auth Service : ![Diagramme de classes Auth-Service](docs/architecture/4+1/logicalView/classDiagramAuth.png)&#10;- Matching Service : ![Diagramme de classes Matching-Service](docs/architecture/4+1/logicalView/classDiagramMatching.png)&#10;- Order Service : ![Diagramme de classes Order-Service](docs/architecture/4+1/logicalView/classDiagramOrder.png)&#10;- Wallet Service : ![Diagramme de classes Wallet-Service](docs/architecture/4+1/logicalView/classDiagramWallet.png)&#10;&#10;### Contexte&#10;La vue logique présente la structure interne du système, organisée autour de quatre microservices principaux : Auth-Service, Matching-Service, Order-Service et Wallet-Service. Chaque service possède son propre modèle métier, adapté à ses responsabilités fonctionnelles : gestion des utilisateurs et de l’authentification, appariement des ordres, gestion des transactions et des ordres, gestion des portefeuilles et des positions boursières.&#10;&#10;### Éléments&#10;- **Auth-Service** : User, MfaChallenge, VerificationToken, UserAudit&#10;- **Matching-Service** : OrderBook, ExecutionReport&#10;- **Order-Service** : Order&#10;- **Wallet-Service** : Wallet, StockPosition, StockRule, Transaction, WalletAudit&#10;- Enums et value objects spécifiques à chaque domaine&#10;&#10;### Relations&#10;- Les entités de chaque microservice sont liées par des relations métier propres à leur domaine (ex : un Wallet possède des StockPositions et des Transactions ; un User possède des MfaChallenges et des UserAudits ; un Order est audité et typé ; le MatchingEngine gère des Reports et des OrderBooks).&#10;- Les enums et value objects enrichissent la sémantique métier et garantissent la cohérence des règles de gestion.&#10;- Les diagrammes illustrent la séparation stricte des responsabilités entre les microservices, tout en assurant l’intégrité des processus métier globaux.&#10;&#10;### Rationnel&#10;Cette vue permet de comprendre la logique métier profonde du système, d’assurer la cohérence du modèle et de faciliter la maintenance et l’évolution du code. La séparation en microservices, chacun doté de son propre modèle, favorise la robustesse, la scalabilité et l’évolutivité. Les diagrammes de classes détaillent les dépendances et les relations entre les entités, ce qui aide à anticiper les impacts des évolutions fonctionnelles et à garantir la solidité du système. Cette documentation est essentielle pour la formation des nouveaux développeurs, la validation des règles métier et la communication avec les parties prenantes. Elle pourra également servir dans le futur quand il faudra ajouter de nouveaux microservices, car on connaîtra déjà le contexte des autres microservices.&#10;&#10;## 9. Vue Processus (C&amp;C)&#10;&#10;### Diagrammes&#10;&#10;#### UC01 — Séquence&#10;![UC01 - Séquence](docs/architecture/4+1/processView/sequenceDiagrams/sequenceDiagramUC01.png)&#10;&#10;#### UC01 — Activité&#10;![UC01 - Activité](docs/architecture/4+1/processView/activityDiagrams/activityDiagramUC01.png)&#10;&#10;#### UC02 — Séquence&#10;![UC02 - Séquence](docs/architecture/4+1/processView/sequenceDiagrams/sequenceDiagramUC02.png)&#10;&#10;#### UC02 — Activité&#10;![UC02 - Activité](docs/architecture/4+1/processView/activityDiagrams/activityDiagramUC02.png)&#10;&#10;#### UC03 — Séquence&#10;![UC03 - Séquence](docs/architecture/4+1/processView/sequenceDiagrams/sequenceDiagramUC03.png)&#10;&#10;#### UC03 — Activité&#10;![UC03 - Activité](docs/architecture/4+1/processView/activityDiagrams/activityDiagramUC03.png)&#10;&#10;#### UC05 — Séquence&#10;![UC05 - Séquence](docs/architecture/4+1/processView/sequenceDiagrams/sequenceDiagramUC05.png)&#10;&#10;#### UC05 — Activité&#10;![UC05 - Activité](docs/architecture/4+1/processView/activityDiagrams/activityDiagramUC05.png)&#10;&#10;#### UC07 — Séquence&#10;![UC07 - Séquence](docs/architecture/4+1/processView/sequenceDiagrams/sequenceDiagramUC07.png)&#10;&#10;#### UC07 — Activité&#10;![UC07 - Activité](docs/architecture/4+1/processView/activityDiagrams/activityDiagramUC07.png)&#10;&#10;### Contexte&#10;La vue processus détaille le comportement dynamique du système lors de l’exécution des cas d’utilisation. Elle montre comment les composants collaborent pour réaliser les opérations métier, gérer les erreurs et orchestrer les interactions. L’ajout du UC07 (Appariement interne &amp; Exécution) met en lumière la logique centrale du matching, la gestion des différents types d’ordres (DAY, IOC, FOK) et les alternatives métier, illustrant la complexité et la robustesse du moteur d’appariement.&#10;&#10;### Éléments&#10;- Services applicatifs (RegistrationService, AuthService, WalletService, OrderService, MatchingService)&#10;- Contrôleurs web (UserController, AuthController, WalletController, OrderController, OrderBookController)&#10;- Moteur d’appariement interne (MatchingService)&#10;- Adapters (UserAdapter, TransactionAdapter, OrderBookAdapter, etc.)&#10;- Persistance (JPA Repos)&#10;- Acteurs externes (Client)&#10;&#10;### Relations&#10;- Les contrôleurs reçoivent les requêtes des clients et délèguent aux services&#10;- Les services orchestrent la logique métier et interagissent avec les adapters&#10;- Les adapters font le lien avec la persistance et les systèmes externes&#10;- Les diagrammes d’activité synthétisent les étapes clés et les alternatives&#10;&#10;### Rationnel&#10;Cette vue permet de visualiser le flow des opérations, la gestion des exceptions, l’idempotence et la coordination entre les modules. Elle est essentielle pour valider la robustesse, la sécurité et la performance du système lors des opérations critiques. Elle aide à identifier les points de synchronisation, les risques de concurrence, et à optimiser la répartition des responsabilités. Elle est aussi précieuse pour l’analyse des scénarios d’erreur, la traçabilité des actions et la préparation des tests d’intégration et de non-régression.&#10;&#10;## 10. Vue Développement&#10;&#10;### Diagrammes&#10;- ![Diagramme de composants global](docs/architecture/4+1/developmentView/componentDiagram-global.png)&#10;- ![Diagramme de composants Auth Service](docs/architecture/4+1/developmentView/componentDiagram-auth.png)&#10;- ![Diagramme de composants Order Service](docs/architecture/4+1/developmentView/componentDiagram-order.png)&#10;- ![Diagramme de composants Wallet Service](docs/architecture/4+1/developmentView/componentDiagram-wallet.png)&#10;- ![Diagramme de composants Matching Service](docs/architecture/4+1/developmentView/componentDiagram-matching.png)&#10;- ![Diagramme de packages](docs/architecture/4+1/developmentView/BrokerX___Package_Diagram-BrokerX_Monolith___Package_Diagram.png)&#10;&#10;### Contexte&#10;La vue développement présente l’organisation du code source, la structure des dossiers, la modularité et les dépendances internes. Elle met en avant la façon dont le projet est découpé pour faciliter le travail des développeurs. Elle propose une double vision : une vue globale de l’architecture (tous les microservices et l’infrastructure) et une vue détaillée de la structure interne de chaque microservice métier.&#10;&#10;### Éléments&#10;- Packages principaux : adapters, domain, infrastructure&#10;- Composants techniques : contrôleurs, services, adapters, ports&#10;- Diagrammes de composants pour chaque microservice (auth, order, wallet, matching)&#10;- Structure des dossiers et conventions de nommage&#10;&#10;### Relations&#10;- Les packages sont organisés selon l’architecture hexagonale&#10;- Les dépendances entre modules sont explicites et maîtrisées&#10;- La séparation entre microservices et infrastructure est clairement illustrée&#10;- Les conventions facilitent la maintenance et l’évolution&#10;&#10;### Rationnel&#10;Cette vue facilite la compréhension du projet pour les développeurs, la maintenance et l’évolution du code. La double vision (globale + microservices) favorise la modularité, la réutilisabilité et la robustesse de l’application. Elle permet d’anticiper les impacts des changements, d’améliorer la qualité du code et de réduire les risques de dette technique. Elle est aussi utile pour l’onboarding, la gestion des versions et la collaboration entre équipes.&#10;&#10;## 11. Concepts transversaux&#10;&#10;### 11.1 Modèle de persistance et de domaine&#10;&#10;Avant d’aborder la structure des données, voici le diagramme ERD qui présente les principales entités persistées et leurs relations dans BrokerX. Ce schéma permet de visualiser la base du modèle de données et les liens entre les tables.&#10;&#10;#### Diagramme ERD&#10;![Diagramme ERD BrokerX](/docs/persistance/schemas/schema_er.png)&#10;&#10;Le tableau suivant détaille chaque table du modèle de persistance, avec une brève description de son rôle dans le système.&#10;&#10;#### Tableau 1. Tables de persistance&#10;&#10;| Nom                | Description                                                                                                      |&#10;|--------------------|------------------------------------------------------------------------------------------------------------------|&#10;| User               | Stocke les utilisateurs : email, mot de passe, nom, adresse, date de naissance, statut, solde, etc.              |&#10;| UserAudit          | Journalise les actions utilisateur : action, timestamp, document hash, IP, user agent, session token.            |&#10;| Transaction        | Stocke les transactions : montant, type (dépôt, retrait, achat, vente), statut, description, dates.              |&#10;| Order              | Stocke les ordres de trading : symbole, côté (achat/vente), type, quantité, prix, durée, statut, raison rejet.   |&#10;| MfaChallenge       | Stocke les défis MFA : code, date de création/expiration, état d’utilisation, IP, tentatives, verrouillage.      |&#10;| VerificationToken  | Stocke les tokens de vérification : hash du token, date d’expiration.                                            |&#10;&#10;Pour mieux comprendre la logique métier et les interactions entre les objets, le diagramme de classes ci-dessous illustre les entités principales et leurs relations dans le code.&#10;&#10;#### Diagramme de classes&#10;![Diagramme de classes BrokerX](/docs/persistance/schemas/schema_uml.png)&#10;&#10;Le tableau suivant présente chaque entité du modèle de domaine, avec une explication de son rôle métier.&#10;&#10;#### Tableau 2. Modèle de domaine&#10;&#10;| Nom d’entité         | Description métier                                                                                           |&#10;|----------------------|-------------------------------------------------------------------------------------------------------------|&#10;| User                 | Représente un utilisateur, gère l’activation, le rejet, le crédit du solde, et les statuts de compte.        |&#10;| UserAudit            | Permet de tracer toutes les actions importantes réalisées par un utilisateur.                                |&#10;| Transaction          | Représente une opération financière : dépôt, retrait, achat ou vente, avec gestion d’idempotence et statut.  |&#10;| Order                | Représente un ordre de trading, avec gestion du type, quantité, prix, durée, statut et raison de rejet.      |&#10;| MfaChallenge         | Gère les défis MFA, leur validité, expiration, utilisation et verrouillage en cas d’échecs.                  |&#10;| VerificationToken    | Gère les tokens de vérification pour l’activation de compte ou la récupération d’accès.                      |&#10;&#10;Puis, voici les principales méthodes métier de l’entité User, qui illustrent les opérations clés sur les comptes utilisateurs.&#10;&#10;#### Tableau 3. Méthodes métier importantes sur User&#10;&#10;| Méthode              | Description                                                                                                 |&#10;|----------------------|------------------------------------------------------------------------------------------------------------|&#10;| activate()           | Active le compte utilisateur.                                                                              |&#10;| reject()             | Rejette le compte utilisateur.                                                                             |&#10;| creditBalance(amount)| Ajoute un montant au solde de l’utilisateur.                                                               |&#10;&#10;#### Modèle de domaine&#10;&#10;Le diagramme de modèle de domaine ci-dessous synthétise les entités principales, leurs relations et les règles métier fondamentales de BrokerX. Il offre une vue conceptuelle du cœur métier, indépendante des choix techniques de persistance ou d’implémentation.&#10;&#10;![Diagramme du modèle de domaine](docs/ddd/mdd/MDD.png)&#10;&#10;Ce modèle permet de visualiser rapidement les objets métier, leurs interactions et les invariants structurants du domaine de courtage en ligne.&#10;&#10;### 11.2 Persistance&#10;&#10;BrokerX utilise une base de données PostgreSQL pour stocker toutes les données métier : utilisateurs, ordres, transactions, défis MFA, tokens de vérification et journaux d’audit. La base est persistée sur disque, et la localisation du fichier de données est gérée par la configuration Docker : le volume nommé `postgres_data` assure la persistance des données, même lors du redémarrage ou de la mise à jour des conteneurs.&#10;&#10;Toutes les opérations sur la base de données passent par JPA, avec Hibernate comme fournisseur. Les entités persistées sont décrites dans la section Domain Models. L’accès aux entités se fait exclusivement via les repositories Spring Data JPA, garantissant une abstraction et une sécurité des accès.&#10;&#10;Aucune donnée métier n’est stockée en mémoire ou dans des fichiers plats : toutes les informations critiques (identité, ordres, transactions, MFA, audit) sont centralisées dans PostgreSQL pour garantir la fiabilité, la traçabilité et la conformité réglementaire.&#10;&#10;Les fichiers statiques (templates Thymeleaf, ressources front-end) sont embarqués dans le JAR de l’application et servis par Spring Boot. Aucun fichier utilisateur (image, document, etc.) n’est stocké en dehors de la base : toutes les pièces justificatives ou documents d’audit sont référencés par leur hash dans la base, assurant l’intégrité et la non-répudiation.&#10;&#10;La configuration de la connexion à la base de données (URL, utilisateur, mot de passe) est externalisée dans les fichiers de propriétés et les variables d’environnement Docker, permettant une gestion flexible des environnements de développement, test et production.&#10;&#10;En résumé, la persistance des données dans BrokerX repose sur :&#10;- PostgreSQL pour toutes les données métier et d’audit&#10;- Docker volumes pour la durabilité des données&#10;- Spring Data JPA pour l’accès aux entités&#10;- Aucun stockage de fichiers binaires ou documents en dehors de la base&#10;&#10;Cette approche garantit la robustesse, la conformité et la portabilité du système, tout en facilitant la maintenance et la migration des données.&#10;&#10;#### 11.2.1 Choix ORM ou DAO&#10;Le projet BrokerX utilise l’ORM JPA/Hibernate pour la gestion de la persistance, car il offre une abstraction puissante entre le modèle objet Java et la base de données relationnelle. L’ORM permet de définir les entités métier avec l’annotation `@Entity`, de gérer les relations (OneToMany, ManyToOne, etc.), et de bénéficier de la génération automatique des requêtes SQL. Les accès aux données sont réalisés via des interfaces annotées `@Repository`, qui héritent des interfaces Spring Data (JpaRepository, CrudRepository). Cette approche réduit le code boilerplate, facilite la maintenance et la testabilité, et permet de profiter de la gestion transactionnelle native de Spring. Contrairement à une approche DAO classique, qui nécessite d’écrire manuellement chaque requête et chaque mapping, l’ORM centralise la logique de persistance et garantit la cohérence entre le code et la base. Ce choix est particulièrement pertinent pour BrokerX, qui doit gérer des entités complexes, des relations multiples et des évolutions fréquentes du modèle.&#10;&#10;#### 11.2.2 Transactions&#10;La gestion des transactions est assurée par l’annotation `@Transactional` sur les services et les repositories critiques (ex : WalletDepositService, OrderRepository, TransactionRepository, MfaChallengeAdapter). Spring gère automatiquement le début, la validation et le rollback des transactions, ce qui garantit l’atomicité des opérations et la cohérence des données. Les transactions couvrent les opérations sensibles comme les dépôts, les placements d’ordres, la gestion des MFA et la création de tokens. En cas d’erreur ou d’exception, toutes les modifications sont annulées pour éviter les incohérences.&#10;&#10;#### 11.2.3 Contraintes d’intégrité&#10;Les contraintes d’intégrité sont définies dans les scripts de migration SQL (Flyway) et dans les entités JPA. On retrouve des clés primaires, des clés étrangères, des contraintes d’unicité (ex : client_order_id), des contraintes NOT NULL, et des index pour optimiser les accès. Par exemple, la table `orders` possède une contrainte d’unicité sur `client_order_id` pour éviter les doublons, et toutes les relations sont sécurisées par des clés étrangères avec gestion des cascades. Les entités JPA reflètent ces contraintes via les annotations (@Id, @Column(nullable = false), @UniqueConstraint, @ManyToOne, etc.), ce qui assure une double validation côté code et côté base de données.&#10;&#10;#### 11.2.4 Migrations reproductibles&#10;Les migrations de schéma sont gérées par Flyway, avec des scripts SQL versionnés dans le dossier `db/migration`. Chaque modification de la structure de la base (création de table, ajout de colonne, contrainte, index) est tracée et appliquée de façon déterministe sur tous les environnements. Flyway garantit que chaque migration est idempotente, traçable et réversible. Cela permet de synchroniser la base entre les développeurs, les environnements de test et de production, et de revenir à un état antérieur en cas de problème. Les scripts sont testés et validés à chaque livraison, et la stratégie de versionnement évite les conflits et les pertes de données.&#10;&#10;#### 11.2.5 Données seed&#10;Des données de seed sont insérées via le script `V12__Insert_seed_data.sql`. Ce script permet de peupler la base avec des utilisateurs, des ordres, des transactions et des MFA pour les démonstrations et les tests. Les données seed facilitent la validation fonctionnelle, la démo du produit et la reproductibilité des scénarios métier. Elles sont conçues pour couvrir les principaux cas d’utilisation et garantir que le système démarre toujours dans un état cohérent et exploitable.&#10;&#10;&#10;### 11.3 Interface Utilisateur&#10;&#10;L’interface utilisateur de BrokerX est une application web classique, rendue côté serveur avec Thymeleaf et servie par Spring Boot. Elle propose une navigation fluide et sécurisée pour toutes les opérations de courtage : inscription, authentification MFA, gestion du portefeuille, passage d’ordres et consultation des historiques.&#10;&#10;L’UI utilise HTML, CSS et JavaScript, avec un thème sobre et responsive adapté aux besoins financiers. Toutes les interactions passent par des formulaires web et des appels REST sécurisés.&#10;&#10;Aucune interface mobile native ou SPA n’est fournie par défaut : l’accès se fait exclusivement via le navigateur web.&#10;&#10;### 11.4 Optimisation JavaScript et CSS&#10;&#10;L’optimisation des ressources JavaScript et CSS dans BrokerX est volontairement simple : aucun framework externe, gestionnaire de dépendances ou outil de minification n’est utilisé. Tout le code JavaScript et CSS est écrit en inline directement dans les templates Thymeleaf, ce qui évite toute dépendance supplémentaire et simplifie le déploiement.&#10;&#10;Aucune bibliothèque tierce (npm, bower, webjars, wro4j, etc.) n’est requise : l’ensemble des scripts et styles nécessaires à l’interface sont embarqués dans le JAR et servis par Spring Boot. Cette approche garantit la portabilité et la maintenance, tout en limitant la surface d’attaque et les risques liés aux mises à jour de dépendances externes.&#10;&#10;En résumé : tout le CSS et le JavaScript de BrokerX est inline, intégré dans les templates, sans optimisation ou minification avancée.&#10;&#10;### 11.5 Traitement des transactions&#10;&#10;BrokerX s’appuie sur Spring Boot pour la gestion des transactions locales au sein du JPA EntityManager. Toutes les opérations critiques (ordres, dépôts, retraits, MFA) sont traitées de façon transactionnelle pour garantir la cohérence des données. BrokerX ne supporte pas les transactions distribuées.&#10;&#10;### 11.6 Gestion de session&#10;&#10;BrokerX expose uniquement une API publique stateless : aucune gestion de session côté serveur. L’authentification et l’autorisation sont gérées par des tokens JWT et MFA, sans stockage de session.&#10;&#10;### 11.7 Sécurité&#10;&#10;La sécurité des endpoints API BrokerX repose sur l’authentification forte (MFA, JWT) et le chiffrement TLS. Les accès sont contrôlés par des rôles et toutes les opérations sensibles sont journalisées. Pour renforcer la sécurité, l’application peut être déployée derrière un proxy SSL ou avec la configuration TLS du conteneur Tomcat embarqué.&#10;&#10;Ce niveau de sécurité est adapté au type de données gérées et aux exigences réglementaires du secteur financier.&#10;&#10;### 11.8 Sûreté&#10;&#10;Aucune partie du système BrokerX ne présente de risque vital ou d’impact sur la sécurité physique des utilisateurs.&#10;&#10;### 11.9 Communications et intégration&#10;&#10;BrokerX communique principalement via des API REST sécurisées (HTTPS) et SMTP pour l’envoi d’e-mails. Aucune file de messages ou broker interne n’est utilisé : toutes les intégrations externes (KYC, notifications, audit) passent par des appels HTTP ou SMTP. Les messages ne sont pas persistés en dehors de la base de données métier.&#10;&#10;### 11.10 Vérifications de plausibilité et de validité&#10;&#10;La validation des types et des plages de données est assurée par des annotations JSR-303 sur les entités du domaine (ex : @NotNull). Les contrôleurs REST et services métier vérifient systématiquement la conformité des données reçues.&#10;&#10;Principales règles métier :&#10;- Un utilisateur désactivé ou rejeté ne peut pas passer d’ordre ni déposer de fonds (contrôlé dans UserService et OrderService).&#10;- Un ordre ne peut être placé que si le solde du portefeuille est suffisant (contrôlé dans OrderService).&#10;- Un dépôt doit être strictement positif (contrôlé dans WalletDepositService).&#10;&#10;Les contrôles sont réalisés à la fois au niveau des entités (annotations) et dans les services métier pour garantir la cohérence métier et la sécurité des opérations.&#10;&#10;### 11.11 Gestion des exceptions/erreurs&#10;&#10;Les erreurs de validation (données invalides, contraintes métier) sont mappées sur des codes HTTP appropriés (400, 403, 422) et retournées par les contrôleurs Spring. Les erreurs techniques (base de données, réseau, SMTP) sont loguées et peuvent entraîner l’échec de la requête ou une réponse 500.&#10;&#10;Les contrôleurs REST gèrent la conversion des exceptions en réponses HTTP standardisées. Les erreurs critiques sont journalisées pour analyse et audit.&#10;&#10;### 11.12 Journalisation et traçabilité&#10;&#10;BrokerX journalise toutes les actions critiques des utilisateurs (connexion, ordres, dépôts, MFA, vérification) dans la table UserAudit de la base PostgreSQL. Chaque entrée contient l’action, le timestamp, l’IP, le user agent et le token de session. Les transactions et les placements d'ordre sont également journalisés dans les tables Transaction et Order.&#10;&#10;La journalisation technique (logs applicatifs) est assurée via SLF4J et la configuration par défaut de Spring Boot : les logs sont envoyés en stdout et peuvent être collectés par l’infrastructure d’hébergement.&#10;&#10;La traçabilité métier est garantie par la persistance des logs d’audit en base, permettant l’analyse, la conformité et la détection d’anomalies. Les noms des loggers correspondent aux packages des classes pour faciliter l’identification des modules dans les logs.&#10;&#10;### 11.13 Configurabilité&#10;&#10;BrokerX utilise Spring Boot pour la gestion de la configuration. Les propriétés principales sont définies dans `src/main/resources/application.properties` pour le développement, et surchargées par `application-prod.properties` en production. Il est possible d’ajouter ou de modifier des propriétés via des variables d’environnement ou des fichiers spécifiques à l’environnement (ex : application-test.properties).&#10;&#10;Tableau 13. Principales propriétés de configuration BrokerX&#10;&#10;| Propriété                        | Valeur par défaut (dev)                                             | Description                                      |&#10;|----------------------------------|---------------------------------------------------------------------|--------------------------------------------------|&#10;| spring.application.name          | LOG430_BrokerX                                                      | Nom de l’application                             |&#10;| spring.datasource.url            | jdbc:postgresql://localhost:5432/brokerxdb                          | URL de la base de données PostgreSQL             |&#10;| spring.mail.host                 | smtp.gmail.com                                                      | Hôte SMTP pour l’envoi d’e-mails                 |&#10;| server.port                      | 8081 (dev) 8090 (prod)                                             | Port HTTP de l’application (dev)                 |&#10;| jwt.secret                       | your-256-bit-secret-key-for-development-change-in-production-please | Clé secrète JWT (dev)                            |&#10;| jwt.expiration                   | 86400000                                                            | Durée de validité des tokens JWT (ms)            |&#10;| spring.thymeleaf.cache           | false                                                               | Cache des templates Thymeleaf                    |&#10;| management.endpoints.web.exposure.include | health,info,metrics                                                 | Endpoints exposés pour le monitoring             |&#10;| app.base-url                     | http://localhost:8090 (prod)                                        | URL de base de l’application (prod)              |&#10;| logging.level.com.monolitique.log430 | INFO (prod)                                                         | Niveau de log pour le code métier                |&#10;&#10;La configuration est centralisée et facilement modifiable selon l’environnement (développement, production). Les propriétés sensibles (mots de passe, clés) doivent être gérées via des variables d’environnement en production.&#10;&#10;### 11.14 Internationalisation&#10;&#10;L’unique langue supportée par BrokerX est le français. Il n’existe aucun mécanisme d’internationalisation dans l’interface utilisateur ou l’API, et aucune évolution n’est prévue à ce sujet.&#10;&#10;### 11.15 Migration&#10;&#10;BrokerX est une application développée from scratch en Java/Spring Boot. Aucune migration de données ou d’application antérieure n’a été réalisée : toutes les données ont été créées directement dans la base PostgreSQL du projet.&#10;&#10;### 11.16 Testabilité&#10;&#10;Le projet contient des tests automatisés (JUnit) dans le dossier standard `src/test/java` d’un projet Maven. Les tests couvrent les services métier, les contrôleurs web et les entités principales. Les tests sont exécutés à chaque build Maven et ne doivent pas être ignorés.&#10;&#10;### 11.17 Gestion du build&#10;&#10;L’application se construit avec Maven sans dépendances externes hors Maven. Toutes les étapes (compilation, tests, packaging) sont automatisées via le pipeline CI/CD. Le build produit un JAR exécutable prêt à être déployé dans Docker.&#10;&#10;## 12. Décisions d'architecture&#10;&#10;### 12.1 Architecture hexagonale vs MVC&#10;&#10;# ADR 001 : Architecture hexagonale vs MVC&#10;&#10;**Statut** : Acceptée\&#10;**Date** : 2025-09-23&#10;&#10;## Contexte&#10;Le projet BrokerX doit adopter une structure claire, évolutive et adaptée à la complexité métier (gestion d’ordres, portefeuille, sécurité, intégration de services externes). Deux styles sont envisagés : MVC (Model-View-Controller) et Hexagonal (Ports &amp; Adapters).&#10;## Décision&#10;Nous choisissons l’architecture hexagonale pour BrokerX. Ce style permet une séparation stricte du domaine métier des dépendances techniques, facilite l’intégration de nouveaux services, la testabilité, et prépare le projet à une éventuelle modularisation ou migration vers des microservices.&#10;## Conséquences&#10;- Le domaine métier est indépendant des frameworks et de l’infrastructure.&#10;- Les ports et adapters facilitent l’intégration de services externes.&#10;- La structure est plus modulaire et évolutive qu’un MVC classique.&#10;- La courbe d’apprentissage peut être plus élevée pour les nouveaux développeurs.&#10;- La documentation et la communication sont facilitées.&#10;&#10;### 12.2 Persistance des données&#10;&#10;# ADR 002 : Persistance des données&#10;&#10;**Statut** : Acceptée\&#10;**Date** : 2025-09-23&#10;&#10;## Contexte&#10;BrokerX doit stocker de façon fiable les utilisateurs, ordres, transactions, stocks, et assurer la traçabilité (audit). Plusieurs options sont possibles : base de données relationnelle, NoSQL, fichiers, etc.&#10;&#10;## Décision&#10;Nous retenons une base de données relationnelle (ex : PostgreSQL) pour la persistance principale. Les ports du domaine définissent les interfaces, et les adapters d’infrastructure implémentent l’accès aux données via JPA/Hibernate.&#10;&#10;## Conséquences&#10;- Les modèles métier sont mappés sur des tables relationnelles.&#10;- La cohérence transactionnelle est assurée.&#10;- La migration vers d’autres solutions (NoSQL, cloud) reste possible via de nouveaux adapters.&#10;- Les requêtes complexes et la traçabilité sont facilitées.&#10;- La gestion des migrations de schéma doit être planifiée.&#10;&#10;### 12.3 Journalisation des opérations utilisateur&#10;&#10;# Journalisation des opérations utilisateur&#10;&#10;**Statut** : Acceptée\&#10;**Date** : 2025-09-23&#10;&#10;## Contexte&#10;La traçabilité des actions des utilisateurs est essentielle pour la conformité réglementaire (KYC/AML), la sécurité et l’analyse métier. Plusieurs approches sont possibles : logs applicatifs, solutions externes (ELK, SIEM), ou persistance dédiée en base de données. Il faut garantir la robustesse, la facilité d’accès et la pérennité des données d’audit.&#10;&#10;## Décision&#10;Nous avons choisi de créer une table dédiée `UserAudit` dans la base de données. Toutes les opérations importantes (inscription, authentification, ordres, transactions, vérifications) sont journalisées avec les informations pertinentes (horodatage, identifiant utilisateur, type d’action, détails). Cette solution permet une requêtabilité directe, une intégration simple avec le domaine, et une conformité aux exigences internes et externes.&#10;&#10;## Conséquences&#10;- La traçabilité est centralisée et facilement accessible pour les audits et analyses.&#10;- La solution est évolutive : de nouveaux types d’événements peuvent être ajoutés facilement.&#10;- Les performances sont maîtrisées, car la journalisation est intégrée au modèle de données.&#10;- L’intégration avec des outils externes reste possible via export ou synchronisation.&#10;- La gestion de la volumétrie et de la rétention des données doit être planifiée pour éviter l’engorgement.&#10;&#10;## 12.4 Justification de l'architecture&#10;&#10;# Architecture de BrokerX&#10;&#10;BrokerX adopte une **architecture hexagonale (Ports &amp; Adapters)**.&#10;&#10;### Justification du choix&#10;- **Séparation stricte du domaine métier** : Le cœur métier (modèles, services, logique métier) est isolé des dépendances techniques (frameworks, bases de données, API externes). Les règles métier restent stables et compréhensibles, même si la technologie évolue.&#10;- **Évolutivité et adaptabilité** : L’architecture hexagonale facilite l’ajout ou le remplacement de services externes (paiement, données de marché, audit) sans impacter le domaine. Par exemple, un changement de fournisseur de paiement n’affecte que l’adapter correspondant.&#10;- **Facilité de test et de validation métier** : Le découplage permet de tester le domaine indépendamment des frameworks, ce qui accélère la validation métier et la détection des régressions. Les ports facilitent la création de mocks pour les tests unitaires et d’intégration.&#10;- **Dépendances dirigées et absence de cycles** : Les dépendances sont orientées du domaine vers les ports, puis vers les adapters, ce qui évite les cycles et rend l’architecture plus robuste et maintenable.&#10;- **Réduction du couplage** : Le domaine ne dépend jamais de l’infrastructure ou des frameworks, ce qui permet de migrer vers une autre technologie (ex : changement de framework, passage à une architecture microservices) sans refonte du métier.&#10;- **Conformité réglementaire et sécurité** : En isolant le métier, on facilite la traçabilité et la conformité (audit, KYC, MFA), car les règles métier sont centralisées et documentées.&#10;- **Clarté et communication** : Ce style favorise une documentation claire et une compréhension partagée entre les équipes métier et technique, car chaque couche a une responsabilité bien définie.&#10;&#10;Ce style répond aux besoins de BrokerX : évolutivité, conformité réglementaire, sécurité, intégration de nouveaux services externes, et robustesse face aux changements technologiques.&#10;&#10;---&#10;&#10;### Architecture monolithique et évolutivité&#10;&#10;BrokerX est une application monolithique : toutes les fonctionnalités métier, la logique applicative et l’intégration technique sont regroupées dans un même déploiement.&#10;- **Un seul artefact déployé** : toutes les couches (domaine, application, infrastructure, configuration) sont assemblées et exécutées ensemble, ce qui simplifie la gestion et la supervision.&#10;- **Centralisation des règles métier** : la logique métier et les processus sont gérés dans un même espace, ce qui facilite la cohérence et la traçabilité.&#10;- **Gestion transactionnelle fiable** : les opérations complexes (dépôt, placement d’ordre, audit) bénéficient d’une gestion transactionnelle robuste, sans complexité distribuée.&#10;- **Modularité interne** : chaque couche et chaque port/adaptateur est clairement séparé, ce qui permet d’ajouter, modifier ou remplacer des modules sans impacter le reste du système.&#10;- **Préparation à la modularisation** : les ports et adapters peuvent être extraits vers des microservices ou modules indépendants si le besoin de scalabilité ou d’évolution se présente.&#10;- **Facilité d’intégration de nouveaux services** : l’ajout de services externes (paiement, données de marché, audit) se fait via de nouveaux adapters, sans toucher au domaine métier.&#10;- **Clarté et robustesse** : la séparation stricte des responsabilités rend le code plus lisible, plus maintenable et facilite l’intégration de nouveaux développeurs.&#10;&#10;Ainsi, BrokerX combine la simplicité et la robustesse du monolithe avec la modularité et l’évolutivité de l’architecture hexagonale.&#10;&#10;---&#10;&#10;### Description des couches et dépendances&#10;&#10;L’architecture se compose des couches suivantes :&#10;- **Domaine** : Entités métier (User, Order, Transaction, Stock…), services métier, ports (interfaces du domaine). Cette couche porte la logique métier, les règles de validation, et les invariants du système.&#10;- **Application** : Orchestration des cas d’utilisation, coordination des services métier, gestion de la logique applicative. Elle fait le lien entre les besoins métier et les interactions techniques, sans dépendre des frameworks.&#10;- **Infrastructure** : Implémentation des ports (adapters), persistance, sécurité, intégration avec les services externes. Cette couche traduit les besoins métier en opérations techniques (accès base de données, appels API, gestion de la sécurité).&#10;- **Configuration** : Paramétrage de la sécurité, des dépendances, et du démarrage de l’application. Elle assemble les composants, injecte les dépendances, et gère l’environnement d’exécution.&#10;&#10;#### Organisation des dépendances&#10;- Le domaine reste totalement indépendant des frameworks et de l’infrastructure, ce qui garantit sa stabilité et sa portabilité.&#10;- Les ports définissent les points d’extension et d’intégration ; les adapters les implémentent pour chaque technologie ou service externe.&#10;- La configuration injecte les dépendances sans créer de cycles, ce qui permet de maîtriser l’ordre d’initialisation et la gestion des ressources.&#10;- Les dépendances sont toujours dirigées, ce qui évite les effets de bord et facilite la maintenance.&#10;&#10;---&#10;&#10;### Contrôle du couplage aux frameworks&#10;&#10;- Le couplage aux frameworks (Spring, persistance, sécurité) est strictement limité à l’infrastructure et à la configuration. Cela permet de changer de framework ou de technologie sans impacter le métier.&#10;- Le domaine ne contient aucune annotation ou dépendance technique, ce qui garantit sa pureté et sa testabilité.&#10;- Le cœur métier peut être réutilisé ou migré vers une autre architecture (microservices, serverless) sans dépendance forte, ce qui protège l’investissement métier.&#10;- Les tests sont facilités, car le domaine peut être mocké ou simulé sans dépendance technique.&#10;&#10;---&#10;&#10;### Illustration de l’architecture&#10;&#10;![Diagramme d'architecture hexagonale](docs/architecture/justifications/architectureDiagram.png)&#10;&#10;---&#10;&#10;### Justification globale&#10;&#10;L’architecture hexagonale appliquée au monolithe BrokerX :&#10;- Permet de faire évoluer la plateforme sans refonte majeure, en isolant le métier des choix techniques.&#10;- Sécurise le domaine contre les changements techniques et réglementaires, en centralisant les règles métier.&#10;- Facilite l’intégration de nouveaux services externes (paiement, données de marché, audit) grâce aux ports et adapters.&#10;- Répond aux exigences de clarté, évolutivité et conformité de l’analyse métier, tout en favorisant la communication entre les équipes.&#10;- Garantit la robustesse et la maintenabilité du système, en évitant les cycles et en maîtrisant les dépendances.&#10;- Prépare la plateforme à une éventuelle migration vers une architecture distribuée ou microservices, sans perte de logique métier.&#10;&#10;&#10;&#10;## 13. Scénarios de Qualité&#10;&#10;### 13.1 Arbre de qualité&#10;&#10;L’arbre de qualité ci-dessous synthétise les principaux attributs de qualité visés par BrokerX : sécurité, performance, disponibilité, maintenabilité, testabilité, évolutivité, traçabilité et conformité. Chaque branche détaille les sous-attributs et les priorités associées.&#10;&#10;![Arbre de qualité BrokerX](./qualityTree.png)&#10;&#10;### 13.2 Scénarios d’évaluation&#10;&#10;**Testabilité / Couverture**&#10;- L’utilisation de JaCoCo pendant le développement et dans le pipeline CI/CD doit garantir un taux de couverture de code d’au moins 95 % sur les classes métier critiques (services, contrôleurs, entités).&#10;&#10;**Testabilité / Indépendance des services externes**&#10;- L’architecture doit permettre de tester toute logique métier dépendant de services externes (ex : envoi d’e-mails, accès base de données, fournisseurs de données de marché) sans avoir besoin de ces services réels. Toutes les dépendances externes doivent être mockables via des interfaces ou des adapters.&#10;&#10;*Exemple :*&#10;- Le service d’envoi de codes MFA utilise une interface EmailProvider. Lors des tests, un mock de cette interface permet de valider la logique métier sans connexion SMTP réelle.&#10;&#10;**Sécurité / MFA et KYC**&#10;- Toute tentative d’accès à une ressource protégée sans authentification MFA ou sans vérification KYC doit être bloquée et journalisée. Les tests automatisés doivent couvrir ces scénarios d’accès non autorisé.&#10;&#10;**Performance / Traitement des ordres**&#10;- Le système doit traiter un ordre d’achat ou de vente en moins de 500 ms (P95) même sous charge. Des tests de performance automatisés doivent valider ce critère.&#10;&#10;**Disponibilité / Résilience**&#10;- En cas de panne d’un composant non critique (ex : service d’e-mail), le système doit continuer à accepter les ordres et journaliser l’incident. Des scénarios de test doivent simuler la défaillance de chaque dépendance externe.&#10;&#10;**Maintenabilité / Évolutivité**&#10;- L’ajout d’un nouveau type d’ordre ou d’un nouveau service externe doit pouvoir se faire sans modification majeure du domaine métier. Des tests d’intégration valident la non-régression lors de l’ajout de nouvelles fonctionnalités.&#10;&#10;**Traçabilité / Audit**&#10;- Toute opération critique (inscription, dépôt, ordre, MFA) doit être journalisée dans la base. Des tests automatisés vérifient la présence des logs d’audit pour chaque scénario métier clé.&#10;&#10;## 14. Risques Techniques&#10;&#10;BrokerX a été conçu selon des standards éprouvés et bénéficie d’une architecture robuste, éprouvée en environnement de développement et de test. À ce jour, aucune faille technique majeure n’a été identifiée pour les scénarios d’utilisation prévus.&#10;&#10;Cependant, certains risques techniques subsistent :&#10;&#10;- **Risque de corruption de la base PostgreSQL** en cas d’arrêt brutal du serveur (panne matérielle, crash OS, coupure électrique). Ce risque est atténué par l’utilisation de volumes Docker persistants et la mise en place de sauvegardes régulières de la base de données.&#10;- **Dépendance à des services externes (SMTP, fournisseurs de données de marché)** : une indisponibilité temporaire de ces services peut impacter certaines fonctionnalités (ex : envoi de codes MFA, notifications). L’architecture prévoit une gestion de la résilience : les ordres et opérations critiques restent acceptés et journalisés même en cas de panne d’un service externe.&#10;- **Montée en charge** : si le nombre d’utilisateurs ou le volume d’ordres croît très rapidement, des ajustements d’infrastructure (scaling, tuning PostgreSQL, optimisation du code) pourraient être nécessaires. Des tests de charge réguliers et une surveillance proactive permettent d’anticiper ce risque.&#10;- **Sécurité** : bien que l’authentification MFA, le KYC et le chiffrement soient en place, le risque d’attaque (phishing, brute force, faille 0-day) ne peut jamais être totalement éliminé.&#10;&#10;En résumé, les principaux risques techniques sont identifiés, documentés et font l’objet de mesures de mitigation adaptées à la criticité de BrokerX.&#10;&#10;## 15. Glossaire&#10;&#10;Le glossaire ci-dessous recense les principaux termes métier utilisés dans BrokerX, en lien direct avec le code et les processus métier de la plateforme.&#10;&#10;Tableau 14. Glossaire métier BrokerX&#10;&#10;| Terme              | Définition                                                                                         |&#10;|--------------------|----------------------------------------------------------------------------------------------------|&#10;| Utilisateur        | Personne inscrite sur la plateforme BrokerX, pouvant effectuer des opérations et gérer son compte. |&#10;| Portefeuille       | Espace virtuel associé à un utilisateur, regroupant son solde en monnaie fiduciaire et ses actifs. |&#10;| Solde              | Montant total disponible dans le portefeuille d’un utilisateur pour effectuer des opérations.      |&#10;| Transaction        | Mouvement de fonds tel qu’un dépôt ou un retrait, ou opération d’achat/vente d’un actif.           |&#10;| Ordre              | Demande formelle d’un utilisateur pour acheter ou vendre un stock. Un ordre contient le symbole, la quantité, le type (marché/limite), le prix (si limite), la durée et le sens (achat/vente). |&#10;| Type d’ordre       | Catégorie d’ordre : Marché (exécuté au prix courant du marché, sans garantie de prix) ou Limite (exécuté uniquement si le prix cible est atteint). |&#10;| Statut d’ordre     | État d’avancement d’un ordre : Pending (en attente), Active (en cours), Rejected (refusé), Completed (exécuté), Expired (périmé). |&#10;| Durée d’ordre      | Période de validité d’un ordre : DAY (valide jusqu’à la fin de la journée), IOC (Immediate or Cancel : exécuté immédiatement ou annulé), FOK (Fill or Kill : exécuté en totalité ou annulé). |&#10;| Bande de prix      | Plage de variation autorisée du prix d’un stock sur une période donnée, pour limiter la volatilité et protéger les investisseurs. |&#10;| Tick Size          | Incrément minimal de variation du prix d’un stock : le prix d’un ordre doit être un multiple du tick size défini pour ce stock. |&#10;| Stock              | Actif financier (ex : action) disponible à l’achat ou à la vente sur BrokerX. Chaque stock possède un symbole, un nom, un prix, une bande de prix et un tick size. |&#10;| ClientOrderId      | Identifiant unique fourni par le client pour tracer et retrouver un ordre dans le système.         |&#10;| KYC                | Processus de vérification d’identité réglementaire (Know Your Customer).                           |&#10;| MFA                | Authentification multi-facteurs pour renforcer la sécurité d’accès à la plateforme.                |&#10;| OTP                | Mot de passe à usage unique, utilisé pour la vérification d’identité ou l’authentification.        |&#10;| Statut utilisateur | État du compte utilisateur : Pending (en attente), Active (actif), Rejected (refusé), Suspended (suspendu). |&#10;| Rejet d’ordre      | Motif pour lequel un ordre est refusé (ex : fonds insuffisants, violation de bande de prix, tick size non respecté, quantité invalide). |&#10;| SimulatedPayment   | Processus simulé de règlement d’un dépôt ou d’un retrait, utilisé pour tester la plateforme.       |&#10;| Audit              | Journalisation des opérations importantes (création de compte, ordres, transactions, etc.).        |&#10;| Session            | Période d’activité authentifiée d’un utilisateur sur la plateforme.                                |&#10;| Rôle utilisateur   | Catégorie d’accès d’un utilisateur (ex : Client, Administrateur).                                 |&#10;| Idempotency Key    | Clé unique permettant d’éviter la duplication d’une opération lors de réessais.                    |&#10;| Statut transaction | État d’une transaction : Pending (en attente), Settled (réglée), Failed (échouée), Completed (terminée). |&#10;| VérificationToken  | Jeton utilisé pour confirmer l’identité ou l’inscription d’un utilisateur.                        |&#10;| Side               | Sens d’un ordre : Achat (Buy) ou Vente (Sell).                                                    |&#10;| Description        | Texte explicatif associé à une transaction ou un ordre.                                           |&#10;| Timestamp          | Date et heure d’enregistrement d’une opération ou d’un ordre.                                     |&#10;| PreTradeValidation | Contrôle métier effectué avant l’acceptation d’un ordre (pouvoir d’achat, règles de prix, tick size, bande de prix, quantité, etc.). |&#10;&#10;" />
              <option name="updatedContent" value="# 1. Introduction &amp; Objectifs&#10;&#10;## 1.1 Objectifs métier&#10;BrokerX est une plateforme de courtage en ligne, désormais migrée vers une architecture microservices (phase 2). Les utilisateurs peuvent s’inscrire, vérifier leur identité, s’authentifier avec MFA, déposer des fonds, placer des ordres et consulter leur portefeuille. L’objectif principal reste d’offrir une expérience sécurisée, fluide et conforme aux exigences réglementaires du secteur financier, tout en améliorant la performance, la disponibilité et la scalabilité grâce au découpage en services indépendants et à l’API Gateway.&#10;&#10;## 1.2 Fonctionnalités essentielles&#10;- Inscription et vérification d’identité (KYC)&#10;- Authentification forte avec MFA&#10;- Gestion du portefeuille virtuel (dépôt, solde)&#10;- Placement d’ordres d’achat et de vente&#10;- Gestion de l’idempotence et de la traçabilité des opérations&#10;- Journalisation des actions et audit de sécurité&#10;- Observabilité avancée (logs structurés, métriques Golden Signals)&#10;&#10;## 1.3 Objectifs de qualité pour l’architecture&#10;&#10;| Objectif de qualité | Scénario concret | Motivation |&#10;|---------------------|------------------|------------|&#10;| Sécurité | Un utilisateur ne peut accéder qu’à ses propres données et toutes les transactions sont chiffrées | Protection des données sensibles et conformité réglementaire |&#10;| Performance | Le système doit répondre à une requête d’ordre en moins de 250 ms (P95) et traiter au moins 800 ordres/s | Expérience utilisateur, compétitivité, passage à l’échelle microservices |&#10;| Disponibilité | Le service doit être disponible 95,5% du temps, même en cas de panne d’un composant | Continuité de service, fiabilité accrue par la résilience des microservices |&#10;| Résilience | En cas d’incident, le système doit pouvoir récupérer et restaurer les opérations sans perte de données | Robustesse et gestion proactive des erreurs |&#10;| Maintenabilité | Les évolutions fonctionnelles doivent pouvoir être réalisées rapidement et sans régression | Réduction des coûts de maintenance et adaptation aux besoins métier |&#10;| Scalabilité | Supporter la croissance du nombre d’utilisateurs et la montée en charge | Pérennité et adaptation à la demande |&#10;| Traçabilité &amp; auditabilité | Toutes les opérations sont journalisées et traçables | Conformité et sécurité |&#10;| Observabilité | Logs structurés et métriques (Golden Signals) accessibles pour le monitoring et l’optimisation | Pilotage de la performance et détection proactive des incidents |&#10;| Conformité | Respect des standards du secteur (tokens, MFA, KYC) | Obligations réglementaires |&#10;&#10;## 1.4 Parties prenantes&#10;&#10;| Partie prenante                  | Rôle                                   | Attente principale |&#10;|----------------------------------|----------------------------------------|--------------------|&#10;| Clients                         | Utilisateurs via interface web/mobile  | Expérience fluide, sécurité des transactions, accès rapide aux cotations et exécution des ordres |&#10;| Opérations Back-Office          | Gestion des règlements, supervision     | Outils de gestion efficaces, visibilité sur les opérations, fiabilité des processus |&#10;| Conformité / Risque             | Surveillance pré- et post-trade         | Accès aux journaux d’audit, alertes en cas d’anomalie, conformité réglementaire garantie |&#10;&#10;Cette section synthétise les besoins métier, techniques et réglementaires qui orientent toutes les décisions architecturales.&#10;&#10;## 1.5 Vue d’ensemble des exigences fonctionnelles&#10;&#10;| Cas d’utilisation | Description | Référence |&#10;|-------------------|-------------|-----------|&#10;| Inscription &amp; vérification d’identité | Permet à un utilisateur de créer un compte et de valider son identité via un processus KYC | UC01.md |&#10;| Authentification &amp; MFA | Permet à un utilisateur de s’authentifier avec mot de passe et code MFA | UC02.md |&#10;| Dépôt dans le portefeuille | Permet à un utilisateur de déposer des fonds dans son portefeuille virtuel | UC03.md |&#10;| Placement d’un ordre | Permet à un utilisateur de placer un ordre d’achat ou de vente sur un actif | UC05.md |&#10;| Appariement interne &amp; Exécution (matching) | Assure l’exécution automatique des ordres selon la priorité prix/temps, rapproche acheteurs et vendeurs, génère les transactions | UC07.md |&#10;| Consultation du portefeuille et des ordres | Permet à un utilisateur de consulter ses positions, ordres et historiques | UC07.md |&#10;&#10;## 1.6 Priorisation MoSCoW des cas d’utilisation&#10;&#10;# Priorisation MoSCoW des cas d'utilisation&#10;&#10;| Cas d'utilisation                                      | Priorité MoSCoW | Justification                                                                                   |&#10;|--------------------------------------------------------|-----------------|-----------------------------------------------------------------------------------------------------------|&#10;| UC-01 — Inscription &amp; Vérification d’identité          | Must            | Sans inscription et vérification, aucun utilisateur ne peut accéder à la plateforme ni respecter les exigences réglementaires (KYC/AML). C'est la base de toute relation de confiance et de conformité légale.|&#10;| UC-03 — Approvisionnement du portefeuille (dépôt virtuel)| Must            | Les utilisateurs doivent pouvoir disposer de liquidités pour effectuer des opérations : sans dépôt, aucune transaction n'est possible, ce qui bloque toute activité sur la plateforme. |&#10;| UC-05 — Placement d’un ordre (marché/limite) avec contrôles pré-trade | Must            | Le placement d'ordre est le cœur du métier : sans cette fonctionnalité, la plateforme ne répond à aucun besoin de courtage et perd toute valeur pour les clients.  |&#10;| UC-02 — Authentification &amp; MFA                         | Must            | La sécurité des accès est indispensable pour la conformité et la confiance : une authentification forte est requise pour garantir la sécurité des comptes et la conformité réglementaire. |&#10;| UC-07 — Appariement interne &amp; Exécution (matching)     | Must            | L'appariement automatique est essentiel pour assurer l'exécution des ordres selon les règles de priorité prix/temps : sans cette mécanique, la plateforme ne peut traiter les transactions de manière fiable et conforme aux standards du secteur. |&#10;| UC-04 — Abonnement aux données de marché               | Should          | Permet aux utilisateurs de prendre des décisions informées, mais la plateforme peut fonctionner sans cette fonctionnalité, en mode minimal ou pour des tests.|&#10;| UC-06 — Modification / Annulation d’un ordre           | Could           | Offre de la flexibilité et réduit les erreurs, mais un MVP peut fonctionner sans cette capacité, en imposant plus de rigueur à l'utilisateur.|&#10;| UC-08 — Confirmation d’exécution &amp; Notifications       | Won't Have      | Utile pour la transparence et l'information client, mais sera exclu de la première version pour se concentrer sur les fonctionnalités essentielles et réduire la complexité technique.|&#10;&#10;&gt; Cette priorisation MoSCoW garantit que les fonctionnalités critiques (Must) sont livrées en priorité pour assurer la valeur métier, la conformité et la sécurité, tandis que les autres (Should/Could) enrichissent l'expérience ou optimisent le service. Les éléments en Won't Have sont explicitement exclus pour permettre une livraison rapide et maîtrisée du périmètre minimal.&#10;&#10;## 1.7 Description détaillée des cas d’utilisation&#10;&#10;### UC-01 — Inscription &amp; Vérification d’identité&#10;&#10;Objectif:&#10;Faciliter l’enregistrement d’un nouvel utilisateur sur la plateforme BrokerX en recueillant ses informations personnelles, en procédant à la vérification réglementaire de son identité (KYC/AML) et en activant son accès. Ce processus initie la relation de confiance entre l’utilisateur et BrokerX.&#10;&#10;Acteur principal:&#10;Client&#10;&#10;Déclencheur:&#10;Le Client souhaite créer un compte pour s'inscrire à la plateforme.&#10;&#10;Pré-conditions:&#10;Aucune.&#10;&#10;Postconditions (succès):&#10;- Un compte utilisateur est créé avec le statut &quot;PENDING&quot;.&#10;- Après la vérification d'identité, le compte passe au statut &quot;ACTIVE&quot;.&#10;&#10;Postconditions (échec):&#10;- Le compte n’est pas créé ou est marqué &quot;REJECTED&quot; avec une raison précisée.&#10;&#10;Flux principal&#10;1. Le Client fournit son email, un mot de passe et les données personnelles requises (nom, adresse, date de naissance).&#10;2. Le Système vérifie la validité des informations et crée un compte avec le statut &quot;PENDING&quot;.&#10;3. Le Système envoie un lien de vérification d’identité par email.&#10;4. Le Client reçoit un lien OTP (one-time passwords) et confirme son identité en cliquant sur le lien.&#10;5. Le Système change le statut du compte à &quot;ACTIVE&quot; et journalise l’opération (horodatage, adresse IP, identifiant).&#10;&#10;Alternatifs / Exceptions&#10;- A1. Vérification d'identité non complétée : Le compte reste avec le statut &quot;PENDING&quot;. Le lien de vérification expire après 1 jour.&#10;- E1. Email déjà utilisé : L'opération d'inscription de l'utilisateur est rejetée. On lui propose d'aller faire un login à la place.&#10;- E2. Informations invalides (email du mauvais format) : Le Système rejette l'inscription et demande au Client de corriger les informations.&#10;&#10;Critère d’acceptation:&#10;Un utilisateur fournit des informations valides, reçoit le lien de vérification, confirme son identité, et son compte passe au statut &quot;ACTIVE&quot;.&#10;&#10;### UC-02 — Authentification &amp; MFA&#10;&#10;Objectif:&#10;Assurer la sécurité d’accès à la plateforme BrokerX en permettant aux clients de s’authentifier via identifiant/mot de passe et un code multi-facteurs (OTP), afin de protéger les comptes contre toute tentative d’accès non autorisée.&#10;&#10;Acteur principal:&#10;Client&#10;&#10;Déclencheur:&#10;Le Client souhaite se connecter à la plateforme.&#10;&#10;Pré-conditions:&#10;Le compte du Client doit être au statut &quot;ACTIVE&quot;.&#10;&#10;Postconditions (succès):&#10;- Une session valide est établie pour le client (token de session).&#10;- Le rôle de &quot;Client&quot; est associé à la session.&#10;&#10;Postconditions (échec):&#10;- Aucune session n’est créée.&#10;- Le Client ne peut pas accéder à la plateforme.&#10;&#10;Flux principal&#10;1. Le Client saisit son identifiant et son mot de passe.&#10;2. Le Système vérifie l’état du compte ainsi que les informations entrées par le client.&#10;3. Le Système envoit un code temporaire à l'utilisation par email.&#10;4. Le Client saisit le code MFA reçu.&#10;5. Le Système valide le code entré, génère le token de session et journalise l’audit (IP, device, horodatage).&#10;&#10;Alternatifs / Exceptions&#10;- E1. Challenge MFA expiré : Si le code MFA n’est pas saisi dans le délai imparti, l’authentification échoue et le Client doit recommencer.&#10;- E2. Challenge MFA déjà utilisé : Si le code MFA a déjà été utilisé, l’authentification échoue et un nouveau challenge doit être généré.&#10;- E3. Échec MFA (3 tentatives) : Après 3 échecs de saisie du code MFA, l'utilisateur est verrouillé pendant 30 secondes et il doit attendre avant de réessayer.&#10;- E4. Compte suspendu : Si le Client rate une 4e fois, son compte est suspendu et il doit contacter le support.&#10;- E5. Compte non actif : Si le compte n’est pas au statut &quot;ACTIVE&quot;, l’authentification est rejetée avec une raison précisée.&#10;&#10;Critère d’acceptation:&#10;Un client saisit ses identifiants valides, reçoit le code MFA, le saisit correctement, et accède à la plateforme avec une session active.&#10;&#10;### UC-03 — Approvisionnement du portefeuille (dépôt virtuel)&#10;&#10;Objectif:&#10;Permettre aux utilisateurs d’augmenter le solde de leur portefeuille virtuel en réalisant des dépôts simulés, afin de garantir la disponibilité des fonds nécessaires pour placer des ordres d’achat sur la plateforme BrokerX.&#10;&#10;Acteur principal:&#10;Client&#10;&#10;Acteurs secondaires:&#10;Service Paiement Simulé&#10;&#10;Déclencheur:&#10;Le Client crédite son solde en monnaie fiduciaire simulée.&#10;&#10;Pré-conditions:&#10;Le compte du Client doit être au statut &quot;ACTIVE&quot;.&#10;&#10;Postconditions (succès):&#10;- Le solde du portefeuille est augmenté.&#10;- Une écriture précise de la transaction effectuée est ajoutée au journal.&#10;&#10;Postconditions (échec):&#10;- Le solde du portefeuille reste inchangé.&#10;- Une écriture d’erreur est ajoutée au journal avec le motif de l’échec.&#10;&#10;Flux principal&#10;1. Le Client saisit le montant à déposer.&#10;2. Le Système vérifie les limites (montant minimum/maximum).&#10;3. Le Système crée une transaction avec le statut &quot;PENDING&quot;.&#10;4. Le Service Paiement Simulé traite la demande et répond &quot;SETTLED&quot;.&#10;5. Le Système crédite le portefeuille, journalise la transaction et notifie le Client du résultat de l'opération.&#10;&#10;Alternatifs / Exceptions:&#10;- E1. Paiement rejeté : La transaction passe au statut &quot;FAILED&quot; et le Client reçoit une notification avec le motif du rejet.&#10;- E2. Idempotence : Si une demande de dépôt avec la même idempotency-key, le Système renvoie le résultat précédent.&#10;- E3. Montant hors limites : Si le montant est inférieur au minimum ou supérieur au maximum autorisé, le dépôt est refusé et le Client est informé.&#10;- E4. Compte non trouvé ou non actif : Si le compte n’existe pas ou n’est pas au statut &quot;ACTIVE&quot;, le dépôt est refusé.&#10;&#10;Critère d’acceptation&#10;Un client saisit un montant valide, la transaction est acceptée, le portefeuille est crédité, et la transaction est journalisée avec succès.&#10;&#10;### UC-05 — Placement d’un ordre (marché/limite) avec contrôles pré-trade&#10;&#10;Objectif:&#10;Offrir aux clients la possibilité de soumettre des ordres d’achat ou de vente (marché ou limite), soumis à des contrôles pré-trade automatisés, afin d’assurer la conformité et la sécurité des opérations sur BrokerX.&#10;&#10;Acteur principal:&#10;Client&#10;&#10;Acteurs secondaires:&#10;Moteur de Règles Pré-trade, Comptes/Portefeuilles&#10;&#10;Déclencheur:&#10;Le Client soumet un ordre.&#10;&#10;Pré-conditions:&#10;Session valide, portefeuille existant.&#10;&#10;Postconditions (succès):&#10;- Ordre accepté et placé dans le carnet interne.&#10;&#10;Postconditions (échec):&#10;- Ordre rejeté avec raison.&#10;&#10;Flux principal&#10;1. Le Client entre le symbole, le sens (ACHAT/VENTE), le type (MARCHE/LIMITE), la quantité, le prix (si limite) et la durée (DAY/IOC/FOK).&#10;2. Le Système normalise les données et horodate l’opération (timestamp système en UTC avec millisecondes).&#10;3. Le Système effectue les contrôles pré-trade :&#10;   - Pouvoir d’achat et marge disponible&#10;   - Règles de prix (bandes, tick size)&#10;   - Interdictions (short-sell n'est pas autorisé)&#10;   - Limites par utilisateur (taille maximales d’ordre)&#10;   - Vérifications de cohérence (quantité &gt; 0)&#10;4. Si tous les contrôles sont validés, le Système attribue un clientOrderId et persiste l’ordre.&#10;&#10;Alternatifs / Exceptions:&#10;- A1. Type Marché : Le prix n’est pas requis, routage immédiat.&#10;- E1. Pouvoir d’achat insuffisant : L’ordre est rejeté avec le motif correspondant.&#10;- E2. Violation bande de prix : L’ordre est rejeté avec le motif correspondant.&#10;- E3. Idempotence : Si un ordre avec le même clientOrderId est reçu, le Système renvoie le résultat précédent.&#10;- E4. Prix limite absent pour ordre limite : L'ordre n'est pas effectué et le Client est informé.&#10;- E5. Quantité non positive : L’ordre n'est pas effectué et le Client est informé.&#10;- E6. Short-sell non autorisé : L’ordre est rejeté avec le motif correspondant.&#10;- E7. Tick size non respecté : L’ordre est rejeté si le prix ne respecte pas l’incrément minimal autorisé.&#10;- E8. Taille maximale d’ordre dépassée : L’ordre est rejeté si la quantité dépasse la limite autorisée pour l’utilisateur.&#10;&#10;Critère d’acceptation:&#10;Un client soumet un ordre valide pour le stock &quot;TEST&quot;, tous les contrôles pré-trade sont passés, l’ordre est accepté et enregistré dans le carnet interne.&#10;&#10;### UC-07 — Appariement interne &amp; Exécution (matching)&#10;&#10;Objectif:&#10;Assurer l’exécution automatique des ordres en interne selon les règles de priorité (prix/temps) en rapprochant acheteurs et vendeurs. Ce cas fournit la mécanique centrale de traitement des transactions sur la plateforme.&#10;&#10;Acteur principal:&#10;Moteur d’appariement interne&#10;&#10;Acteurs secondaires:&#10;Données de Marché, Portefeuilles&#10;&#10;Déclencheur:&#10;Nouvel ordre arrive dans le carnet.&#10;&#10;Pré-conditions:&#10;Carnet maintenu (prix/temps), règles de priorité définies.&#10;&#10;Postconditions (succès):&#10;- Transactions générées (partielles possibles), état d’ordre mis à jour.&#10;&#10;Postconditions (échec):&#10;- Ordre reste Working (pas de contrepartie).&#10;&#10;Flux principal&#10;1. Le Moteur insère l’ordre dans le carnet (Buy/Sell).&#10;2. Il recherche la meilleure contrepartie (price-time priority).&#10;3. Si match, crée une ou plusieurs exécutions (fills), met à jour quantités.&#10;4. Émet événements ExecutionReport (Fill/Partial Fill).&#10;5. Met à jour top-of-book, publie update marché.&#10;&#10;Alternatifs / Exceptions:&#10;- A1. IOC/FOK : IOC exécute le possible puis annule le reste; FOK exécute tout sinon annule.&#10;&#10;Critère d’acceptation:&#10;Un ordre d’achat de 10 actions AAPL à 100 $ rencontre un ordre de vente identique. Résultat attendu : une transaction est générée, les quantités sont ajustées et un rapport d’exécution (Execution Report) est publié.&#10;&#10;## 2. Contraintes d’architecture&#10;&#10;### 2.1 Contraintes techniques&#10;&#10;| Contrainte | Explication |&#10;|------------|------------|&#10;| Monolithe Java/Spring Boot | L’application doit être développée en Java avec le framework Spring Boot, sous forme de monolithe. |&#10;| Base de données PostgreSQL | Toutes les données persistantes doivent être stockées dans une base PostgreSQL. |&#10;| Authentification MFA | L’authentification multi-facteurs est obligatoire pour tous les accès utilisateurs. |&#10;| Docker &amp; Docker Compose | Le déploiement doit se faire via des conteneurs Docker, orchestrés avec Docker Compose. |&#10;| API REST | Les interfaces externes doivent être exposées sous forme d’API REST. |&#10;| Journalisation et audit | Toutes les opérations critiques, y compris les événements d’exécution (fills, partial fills, ExecutionReport), doivent être journalisées pour audit et traçabilité. |&#10;| Caching | Un mécanisme de cache (local ou distribué) doit être utilisé pour optimiser la consultation du carnet d’ordres, du top-of-book et la diffusion des données de marché, afin d’améliorer la performance et limiter la charge sur la base de données. |&#10;| Observabilité | Le système doit fournir des logs structurés, des métriques (Golden Signals) et des traces pour le moteur d’appariement et l’exécution des ordres, afin d’assurer le suivi, la détection des anomalies et la conformité. |&#10;&#10;### 2.2 Contraintes réglementaires et de conformité&#10;&#10;| Contrainte | Explication |&#10;|------------|------------|&#10;| KYC (Know Your Customer) | La vérification d’identité est obligatoire pour chaque utilisateur avant toute opération. |&#10;| Sécurité des données | Chiffrement des données sensibles et respect des standards du secteur financier. |&#10;| Traçabilité | Toutes les actions doivent être traçables et accessibles pour audit. |&#10;&#10;### 2.3 Contraintes organisationnelles&#10;&#10;| Contrainte | Explication |&#10;|------------|------------|&#10;| CI/CD | Les livraisons doivent passer par un pipeline d’intégration et de déploiement continu. |&#10;| Documentation | Toute nouvelle fonctionnalité doit être documentée selon les standards internes. |&#10;| Tests automatisés | Les fonctionnalités critiques, dont le moteur d’appariement interne (matching), doivent être couvertes par des tests automatisés (unitaires, d’intégration et E2E). |&#10;&#10;### 2.4 Contraintes de gestion et maintenance&#10;&#10;| Contrainte | Explication |&#10;|------------|------------|&#10;| Maintenabilité | Le code doit être structuré pour faciliter les évolutions et la correction des bugs. |&#10;| Monitoring | Des outils de monitoring doivent être mis en place pour suivre la santé du système, en particulier le moteur d’appariement : détection des incohérences du carnet, alertes et gestion des rollbacks segmentaires. L’observabilité doit permettre un suivi en temps réel des transactions et du matching. |&#10;&#10;Ces contraintes doivent être respectées tout au long du cycle de vie du projet et orientent toutes les décisions architecturales et techniques.&#10;&#10;## 3. Portée du système et contexte&#10;&#10;### 3.1 Contexte métier&#10;&#10;Le tableau ci-dessous présente les principaux acteurs et leurs interactions, en cohérence avec le diagramme de contexte DDD (voir section 3.2).&#10;&#10;| Acteur / Système         | Interagit avec         | Flux / Description                                                                                 |&#10;|--------------------------|------------------------|---------------------------------------------------------------------------------------------------|&#10;| Client                   | Application BrokerX    | S'inscrit, s'authentifie, effectue des opérations de courtage                                     |&#10;| Application BrokerX      | Service d'Email        | Demande l'envoi de courriels (vérification, MFA, notifications) au Service d'Email                |&#10;| Service d'Email          | Client                 | Envoie les courriels (liens de vérification, codes MFA, notifications) au Client                  |&#10;&#10;### 3.2 Diagramme de contexte DDD&#10;&#10;Le diagramme de contexte ci-dessous illustre les frontières du système BrokerX, ses principaux partenaires externes et les interactions majeures du point de vue métier et DDD.&#10;&#10;![Diagramme de contexte DDD](docs/ddd/diagrammeDeContexte/diagrammeDeContexte.png)&#10;&#10;### 3.3 Diagramme des bounded contexts&#10;&#10;Le diagramme des bounded contexts présente la découpe du domaine BrokerX en sous-domaines fonctionnels cohérents (bounded contexts), chacun représentant une zone de responsabilité métier distincte. Cette vue permet de visualiser les interactions et les frontières entre les différents contextes métier.&#10;&#10;![Diagramme des bounded contexts](docs/ddd/boundedContexts/bounded_contexts.png)&#10;&#10;### 3.4 Contexte technique&#10;&#10;Le diagramme de déploiement ci-dessous illustre l’infrastructure technique et les canaux présentement utilisés par BrokerX.&#10;&#10;![Diagramme de déploiement BrokerX](docs/architecture/4+1/deploymentView/deploymentDiagram.png)&#10;&#10;| Système technique externe         | Canal / Protocole | Format des données | Sécurité | Explication interface |&#10;|-----------------------------------|-------------------|--------------------|----------|----------------------|&#10;| Clients                          | API REST (HTTPS)  | JSON               | MFA, chiffrement TLS | Accès utilisateur, ordres, notifications, cotations temps réel |&#10;| SMTP Provider (GMail)             | SMTP (TLS)        | Texte, HTML        | Chiffrement TLS, authentification SMTP | Envoi d’e-mails pour notifications, vérification d’adresse, récupération de mot de passe |&#10;&#10;Chaque interface technique est sécurisée par chiffrement TLS et, selon le cas, par authentification forte (MFA, tokens, SMTP login). Les explications précisent le rôle et les exigences de chaque interface.&#10;&#10;## 4. Stratégie de solution&#10;&#10;L’architecture de BrokerX repose désormais sur une approche microservices, chaque domaine métier étant isolé dans un service indépendant (auth-service, api-gateway, matching-service, order-service, wallet-service, etc.). Cette stratégie permet une évolutivité, une résilience et une flexibilité accrues, tout en facilitant la maintenance et le déploiement.&#10;&#10;Chaque microservice est développé principalement en Java avec Spring Boot, et expose ses fonctionnalités via des API REST sécurisées (HTTPS/JSON). L’api-gateway centralise l’accès aux services, gère le routage, l’authentification et la sécurité des échanges. Un load balancer avec NGINX est installé entre le gateway et les microservices, afin de pouvoir créer plusieurs instances de certains microservices. Ceci permet une bonne scalabilité et une tolérance aux pannes. Les communications inter-services se font principalement par API REST, mais peuvent évoluer vers des solutions de messaging (ex : Kafka, RabbitMQ) pour les besoins d’asynchronisme ou de scalabilité.&#10;&#10;La persistance des données est gérée de façon indépendante : chaque microservice possède sa propre base de données (PostgreSQL), ce qui garantit l’isolation des données, la conformité aux principes DDD et la robustesse des transactions critiques. Cette séparation permet d’éviter les dépendances fortes et facilite l’évolution de chaque service.&#10;&#10;La sécurité est centralisée via l’auth-service, qui gère l’authentification forte (MFA), la gestion des rôles et la journalisation des actions critiques. Les exigences réglementaires (KYC, RGPD) sont respectées grâce à une gestion fine des accès et à la traçabilité des opérations sensibles.&#10;&#10;Le déploiement et l’orchestration des services sont assurés par Docker et Docker Compose, permettant de gérer facilement les environnements, la scalabilité et la portabilité. Chaque service peut être déployé, mis à jour ou redémarré indépendamment, ce qui réduit les risques et accélère les cycles de livraison.&#10;&#10;Un pipeline CI/CD adapté aux microservices automatise les tests (unitaires, d’intégration, E2E) et les livraisons pour chaque service, garantissant la qualité et la rapidité des mises en production. Les tests sont systématisés pour détecter rapidement les régressions et assurer la fiabilité du système global.&#10;&#10;La documentation des API et des services est produite en continu, facilitant l’intégration de nouveaux membres et l’évolution du système. L’utilisation de standards ouverts (OpenAPI/Swagger) permet de garder une trace claire des interfaces et des contrats entre services.&#10;&#10;Ce choix d’architecture microservices, associé à des technologies éprouvées et à des processus automatisés, permet de répondre efficacement aux objectifs de sécurité, performance, disponibilité et conformité, tout en gardant la solution évolutive pour de futurs besoins. Cette stratégie assure un socle solide pour BrokerX et prépare l’ouverture vers des intégrations ou des évolutions plus complexes.&#10;&#10;## 5. Vue des blocs de construction&#10;&#10;### 5.1 Introduction&#10;Cette section présente la structure statique de BrokerX selon deux niveaux de précision : un premier niveau très high level (système vu comme un bloc, interfaces externes), puis un second niveau qui détaille les principaux composants internes.&#10;&#10;### 5.2 Vue d’ensemble high level (Niveau 1)&#10;![Diagramme high level](./BB_1.png)&#10;Le diagramme ci-dessus illustre les principaux éléments et interactions du système BrokerX :&#10;&#10;| Élément                       | Type / Technologie                       | Rôle / Description                                                                                                                        |&#10;|-------------------------------|------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------|&#10;| Utilisateur                   | Acteur externe                           | Interagit avec BrokerX via l’interface web : navigation, formulaires, requêtes REST, réception d’e-mails                                  |&#10;| API Gateway                   | Service dédié (Spring Cloud Gateway, etc.)| Point d’entrée unique : centralise l’accès, la sécurité et le routage des requêtes vers le load balancer                                  |&#10;| Load Balancer                 | NGINX / Traefik                          | Répartit la charge entre les instances des microservices, assure la haute disponibilité et la résilience du système                       |&#10;| auth-service                  | Microservice Java/Spring Boot             | Gère l’authentification, MFA, gestion des rôles, journalisation des actions critiques                                                     |&#10;| matching-service              | Microservice Java/Spring Boot             | Appariement des ordres selon les règles métier, gestion du carnet d’ordres                                                                |&#10;| order-service                 | Microservice Java/Spring Boot             | Gestion des ordres de trading, validation pré-trade, traçabilité des opérations                                                           |&#10;| wallet-service                | Microservice Java/Spring Boot             | Gestion du portefeuille virtuel, dépôts, solde, transactions                                                                             |&#10;| DB Auth                       | PostgreSQL                               | Stocke les données d’authentification, MFA, rôles                                                                                        |&#10;| DB Matching                   | PostgreSQL                               | Stocke les données d’appariement, carnet d’ordres                                                                                        |&#10;| DB Order                      | PostgreSQL                               | Stocke les ordres, statuts, logs d’exécution                                                                                             |&#10;| DB Wallet                     | PostgreSQL                               | Stocke les portefeuilles, transactions, historiques                                                                                      |&#10;| Système Email (SMTP)          | Service externe                          | Reçoit les demandes d’envoi d’e-mails (liens de vérification, codes MFA) et transmet les courriels à l’utilisateur                       |&#10;&#10;**Principales interactions :**&#10;- L’utilisateur accède à BrokerX via l’API Gateway, qui centralise l’accès, la sécurité et le routage des requêtes&#10;- L’API Gateway route les requêtes vers le load balancer, qui répartit la charge vers les microservices&#10;- Chaque microservice gère un domaine métier spécifique et possède sa propre base PostgreSQL&#10;- Les microservices communiquent avec le système email (SMTP) pour l’envoi de codes MFA et de notifications&#10;- Le système email transmet les e-mails de vérification et de codes à l’utilisateur&#10;&#10;**Données stockées dans les bases :**&#10;- Auth-service : utilisateurs, MFA, rôles&#10;- Matching-service : carnet d’ordres, appariements&#10;- Order-service : ordres, statuts, logs d’exécution&#10;- Wallet-service : portefeuilles, transactions&#10;&#10;Cette vue permet de comprendre la structure globale du système, les principaux composants et leurs interactions, ainsi que la répartition des responsabilités entre les microservices.&#10;&#10;### 5.3 Vue interne des composants (Niveau 2)&#10;![Diagramme de composants](./BB_2.png)&#10;&#10;Le diagramme ci-dessus détaille l’architecture interne du système BrokerX, organisée en microservices :&#10;&#10;| Composant                      | Type / Rôle                                      | Description                                                                 |&#10;|--------------------------------|--------------------------------------------------|-----------------------------------------------------------------------------|&#10;| Utilisateur (Frontend React)   | Acteur externe                                   | Accède à l’application web pour toutes les opérations de courtage           |&#10;| API Gateway                    | Proxy/Routage                                    | Point d’entrée unique, route les requêtes vers les microservices            |&#10;| Load Balancer (NGINX)          | Répartition de charge / proxy                    | Distribue les requêtes vers les instances des microservices, config nginx.conf|&#10;| AuthController                 | Contrôleur (auth-service)                        | Gère l’authentification et la vérification MFA                              |&#10;| UserVerificationController     | Contrôleur (auth-service)                        | Gère la vérification d’identité (KYC)                                       |&#10;| OrderController                | Contrôleur (order-service)                       | Permet de passer et consulter des ordres de trading                         |&#10;| WalletController               | Contrôleur (wallet-service)                      | Gère le portefeuille et les dépôts                                          |&#10;| MatchingController             | Contrôleur (matching-service)                    | Gère le matching des ordres                                                 |&#10;| AuthenticationService          | Service métier (auth-service)                    | Logique d’authentification et MFA                                           |&#10;| RegistrationService            | Service métier (auth-service)                    | Gère l’inscription et la vérification utilisateur                           |&#10;| OrderService                   | Service métier (order-service)                   | Logique métier pour la gestion des ordres                                   |&#10;| PreTradeValidationService      | Service métier (order-service)                   | Valide les ordres avant exécution                                           |&#10;| StockService                   | Service métier (order-service)                   | Gestion des actifs financiers et cotations                                   |&#10;| WalletDepositService           | Service métier (wallet-service)                  | Gère les dépôts dans le portefeuille                                        |&#10;| MatchingService                | Service métier (matching-service)                | Logique de matching d’ordres                                                |&#10;| DB Auth (PostgreSQL)           | Base de données dédiée                           | Stocke les données d’authentification et utilisateurs                       |&#10;| DB Order (PostgreSQL)          | Base de données dédiée                           | Stocke les ordres et historiques de trading                                 |&#10;| DB Wallet (PostgreSQL)         | Base de données dédiée                           | Stocke les informations de portefeuille                                     |&#10;| DB Matching (PostgreSQL)       | Base de données dédiée                           | Stocke les données de matching                                              |&#10;| Système Email (SMTP)           | Service externe                                  | Envoie les notifications et codes MFA aux utilisateurs                      |&#10;&#10;**Principales interactions :**&#10;- L’utilisateur interagit avec le Frontend React, qui transmet les requêtes à l’API Gateway.&#10;- L’API Gateway centralise et sécurise l’accès, puis transmet les requêtes au Load Balancer (NGINX).&#10;- Le Load Balancer distribue les requêtes vers les microservices appropriés (auth-service, order-service, wallet-service, matching-service).&#10;- Chaque microservice possède ses propres contrôleurs et services métier, ainsi qu’une base de données dédiée.&#10;- Les services d’inscription et d’authentification envoient des e-mails (liens de vérification, codes MFA) au système SMTP, qui transmet ces messages à l’utilisateur.&#10;&#10;Cette vue permet de comprendre la répartition des responsabilités, les flux d’information et la collaboration entre les composants, tout en respectant l’architecture microservices et le routage via API Gateway et NGINX.&#10;&#10;### 5.4 Organisation du code et conventions&#10;Le code de chacun des microservices est structuré selon une approche hexagonale : les &quot;adapters&quot; gèrent les interactions externes (web, persistence), le &quot;domain&quot; regroupe la logique métier et les modèles, et &quot;infrastructure&quot; contient la configuration technique. Les conventions de nommage (camelCase) et de structure facilitent l’extension et la maintenance du projet. Les tests automatisés couvrent les fonctionnalités critiques, et la documentation est maintenue à jour pour chaque évolution majeure.&#10;&#10;## 6. Vue d’ensemble des scénarios&#10;&#10;### Diagramme&#10;- ![Diagramme de cas d’utilisation](docs/architecture/4+1/scenarios/useCaseDiagram.png)&#10;&#10;### Contexte&#10;La vue scénarios expose les principaux cas d’utilisation du système BrokerX, tels qu’ils sont vécus par les utilisateurs et les systèmes externes. Elle permet de visualiser les interactions entre le client et l’application, ainsi que les dépendances fonctionnelles entre les différents UC.&#10;&#10;### Éléments&#10;- Acteurs externes : Client (utilisateur principal), Service Paiement Simulé (pour le dépôt), Moteur d’appariement interne (matching), Données de Marché&#10;- Cas d’utilisation : Inscription &amp; vérification d’identité, Authentification &amp; MFA, Dépôt dans le portefeuille, Placement d’un ordre, Appariement interne &amp; Exécution (matching)&#10;&#10;### Relations&#10;- Le client peut initier chacun des cas d’utilisation principaux, sauf l'appariement interne qui est enclenché par le moteur d’appariement interne&#10;- Le dépôt utilise le service de paiement simulé&#10;- Le placement d’un ordre dépend du solde du portefeuille&#10;- Le placement d’un ordre déclenche le cas d’utilisation d’appariement interne &amp; exécution&#10;- L’appariement interne &amp; exécution est réalisé par le moteur d’appariement et utilise les données de marché&#10;&#10;### Rationnel&#10;Cette vue permet de relier les besoins métier aux fonctionnalités du système, de valider la couverture fonctionnelle et d’illustrer les interactions principales, y compris le nouveau processus d’appariement et d’exécution des ordres. L’ajout du cas UC-07 assure que la mécanique centrale de traitement des transactions (matching) est bien couverte, avec la gestion des priorités prix/temps, la génération des transactions et la mise à jour des états d’ordre et des portefeuilles. Les acteurs externes (moteur d’appariement, données de marché, portefeuilles) sont explicitement intégrés pour refléter la réalité technique et métier de la plateforme BrokerX. Cette vue garantit que l’architecture répond bien aux attentes des utilisateurs et des parties prenantes, tout en facilitant la communication entre les équipes métier et technique et en identifiant les scénarios critiques à tester, notamment ceux liés à l’exécution automatique des ordres.&#10;&#10;&#10;## 7. Vue de déploiement&#10;&#10;Le diagramme ci-dessous illustre l’infrastructure technique et la distribution des principaux artefacts du système BrokerX dans une architecture microservices :&#10;&#10;![Diagramme de déploiement BrokerX](docs/architecture/4+1/deploymentView/deploymentDiagram.png)&#10;&#10;| Nœud / Composant                      | Type / Technologie         | Canal / Protocole      | Sécurité / Persistance         | Explication technique                                                                 |&#10;|---------------------------------------|----------------------------|------------------------|-------------------------------|--------------------------------------------------------------------------------------|&#10;| Utilisateur                          | Acteur externe             | -                      | -                             | Interagit via le navigateur web                                                      |&#10;| Frontend (React)                     | Application web            | HTTPS/HTTP 8090        | TLS                           | Interface utilisateur, communique avec l’API Gateway                                 |&#10;| API Gateway                          | Microservice Java/Spring   | HTTPS/HTTP 8080        | TLS, routage                  | Point d’entrée unique, centralise la sécurité et le routage vers les microservices   |&#10;| Load Balancer (NGINX)                | Proxy/Routage              | Interne Docker         | TLS, config nginx.conf         | Répartit la charge entre les microservices, assure la haute disponibilité            |&#10;| auth-service                         | Microservice Java/Spring   | Interne Docker         | TLS, MFA, DB dédiée           | Gère l’authentification, MFA, gestion des rôles, journalisation                      |&#10;| order-service                        | Microservice Java/Spring   | Interne Docker         | TLS, DB dédiée                | Gestion des ordres de trading, validation pré-trade, traçabilité                     |&#10;| wallet-service                       | Microservice Java/Spring   | Interne Docker         | TLS, DB dédiée                | Gestion du portefeuille virtuel, dépôts, solde, transactions                         |&#10;| matching-service                     | Microservice Java/Spring   | Interne Docker         | TLS, DB dédiée                | Appariement des ordres, gestion du carnet d’ordres                                   |&#10;| DB Auth                              | PostgreSQL                 | JDBC 5432              | Authentification, persistance | Stocke les données d’authentification, MFA, rôles                                    |&#10;| DB Order                             | PostgreSQL                 | JDBC 5432              | Persistance                    | Stocke les ordres, statuts, logs d’exécution                                         |&#10;| DB Wallet                            | PostgreSQL                 | JDBC 5432              | Persistance                    | Stocke les portefeuilles, transactions, historiques                                  |&#10;| DB Matching                          | PostgreSQL                 | JDBC 5432              | Persistance                    | Stocke les données d’appariement, carnet d’ordres                                    |&#10;| Volume: postgres_data                | Volume Docker              | Interne Docker         | Persistance                    | Persistance des données PostgreSQL                                                    |&#10;| SMTP Provider (Gmail, Outlook...)    | Service externe (SMTP)     | SMTP 587               | TLS, authentification         | Envoi d’e-mails (notifications, vérification, récupération)                          |&#10;&#10;### Contexte&#10;La vue déploiement décrit l’architecture physique du système : chaque microservice est déployé dans son propre conteneur Docker, tous connectés au même réseau Docker interne (brokerx-network). Le frontend (React) communique avec l’API Gateway, qui centralise la sécurité et le routage. L’API Gateway transmet les requêtes au load balancer (NGINX), qui répartit la charge vers les microservices métier (auth, order, wallet, matching). Chaque microservice possède sa propre base PostgreSQL pour garantir l’isolation des données et la robustesse des transactions. Les volumes Docker assurent la persistance des données, même lors des mises à jour ou redémarrages. Le service SMTP externe gère l’envoi des notifications et des codes MFA. Cette architecture permet une scalabilité horizontale, une haute disponibilité et une maintenance facilitée, chaque service pouvant être mis à jour ou redémarré indépendamment.&#10;&#10;### Éléments&#10;- Conteneurs Docker pour chaque microservice (auth-service, order-service, wallet-service, matching-service, api-gateway, frontend)&#10;- Load Balancer (NGINX) pour la répartition de charge&#10;- Réseau Docker interne (brokerx-network) pour la communication sécurisée&#10;- Bases PostgreSQL dédiées pour chaque microservice&#10;- Volume Docker pour la persistance des données&#10;- Service SMTP externe pour l’envoi d’e-mails&#10;&#10;### Relations&#10;- Le frontend communique avec l’API Gateway via HTTPS&#10;- L’API Gateway transmet les requêtes au load balancer NGINX&#10;- NGINX répartit la charge vers les microservices métier&#10;- Chaque microservice accède à sa propre base PostgreSQL&#10;- Les volumes Docker assurent la persistance des données&#10;- Les microservices communiquent avec le service SMTP pour l’envoi d’e-mails&#10;&#10;### Rationnel&#10;Cette vue permet de comprendre la topologie du système BrokerX dans une architecture microservices : chaque service est isolé, scalable et maintenable indépendamment. Le réseau Docker interne garantit la sécurité et la rapidité des communications. La séparation des bases de données assure la conformité, la robustesse et la traçabilité des opérations. Le load balancer et l’API Gateway centralisent le routage et la sécurité, tandis que le service SMTP gère les notifications critiques. Cette organisation facilite la supervision, la gestion des incidents et l’évolution de l’architecture technique.&#10;&#10;## 8. Vue Logique&#10;&#10;### Diagrammes de classes par microservice&#10;- Auth Service : ![Diagramme de classes Auth-Service](docs/architecture/4+1/logicalView/classDiagramAuth.png)&#10;- Matching Service : ![Diagramme de classes Matching-Service](docs/architecture/4+1/logicalView/classDiagramMatching.png)&#10;- Order Service : ![Diagramme de classes Order-Service](docs/architecture/4+1/logicalView/classDiagramOrder.png)&#10;- Wallet Service : ![Diagramme de classes Wallet-Service](docs/architecture/4+1/logicalView/classDiagramWallet.png)&#10;&#10;### Contexte&#10;La vue logique présente la structure interne du système, organisée autour de quatre microservices principaux : Auth-Service, Matching-Service, Order-Service et Wallet-Service. Chaque service possède son propre modèle métier, adapté à ses responsabilités fonctionnelles : gestion des utilisateurs et de l’authentification, appariement des ordres, gestion des transactions et des ordres, gestion des portefeuilles et des positions boursières.&#10;&#10;### Éléments&#10;- **Auth-Service** : User, MfaChallenge, VerificationToken, UserAudit&#10;- **Matching-Service** : OrderBook, ExecutionReport&#10;- **Order-Service** : Order&#10;- **Wallet-Service** : Wallet, StockPosition, StockRule, Transaction, WalletAudit&#10;- Enums et value objects spécifiques à chaque domaine&#10;&#10;### Relations&#10;- Les entités de chaque microservice sont liées par des relations métier propres à leur domaine (ex : un Wallet possède des StockPositions et des Transactions ; un User possède des MfaChallenges et des UserAudits ; un Order est audité et typé ; le MatchingEngine gère des Reports et des OrderBooks).&#10;- Les enums et value objects enrichissent la sémantique métier et garantissent la cohérence des règles de gestion.&#10;- Les diagrammes illustrent la séparation stricte des responsabilités entre les microservices, tout en assurant l’intégrité des processus métier globaux.&#10;&#10;### Rationnel&#10;Cette vue permet de comprendre la logique métier profonde du système, d’assurer la cohérence du modèle et de faciliter la maintenance et l’évolution du code. La séparation en microservices, chacun doté de son propre modèle, favorise la robustesse, la scalabilité et l’évolutivité. Les diagrammes de classes détaillent les dépendances et les relations entre les entités, ce qui aide à anticiper les impacts des évolutions fonctionnelles et à garantir la solidité du système. Cette documentation est essentielle pour la formation des nouveaux développeurs, la validation des règles métier et la communication avec les parties prenantes. Elle pourra également servir dans le futur quand il faudra ajouter de nouveaux microservices, car on connaîtra déjà le contexte des autres microservices.&#10;&#10;## 9. Vue Processus (C&amp;C)&#10;&#10;### Diagrammes&#10;&#10;#### UC01 — Séquence&#10;![UC01 - Séquence](docs/architecture/4+1/processView/sequenceDiagrams/sequenceDiagramUC01.png)&#10;&#10;#### UC01 — Activité&#10;![UC01 - Activité](docs/architecture/4+1/processView/activityDiagrams/activityDiagramUC01.png)&#10;&#10;#### UC02 — Séquence&#10;![UC02 - Séquence](docs/architecture/4+1/processView/sequenceDiagrams/sequenceDiagramUC02.png)&#10;&#10;#### UC02 — Activité&#10;![UC02 - Activité](docs/architecture/4+1/processView/activityDiagrams/activityDiagramUC02.png)&#10;&#10;#### UC03 — Séquence&#10;![UC03 - Séquence](docs/architecture/4+1/processView/sequenceDiagrams/sequenceDiagramUC03.png)&#10;&#10;#### UC03 — Activité&#10;![UC03 - Activité](docs/architecture/4+1/processView/activityDiagrams/activityDiagramUC03.png)&#10;&#10;#### UC05 — Séquence&#10;![UC05 - Séquence](docs/architecture/4+1/processView/sequenceDiagrams/sequenceDiagramUC05.png)&#10;&#10;#### UC05 — Activité&#10;![UC05 - Activité](docs/architecture/4+1/processView/activityDiagrams/activityDiagramUC05.png)&#10;&#10;#### UC07 — Séquence&#10;![UC07 - Séquence](docs/architecture/4+1/processView/sequenceDiagrams/sequenceDiagramUC07.png)&#10;&#10;#### UC07 — Activité&#10;![UC07 - Activité](docs/architecture/4+1/processView/activityDiagrams/activityDiagramUC07.png)&#10;&#10;### Contexte&#10;La vue processus détaille le comportement dynamique du système lors de l’exécution des cas d’utilisation. Elle montre comment les composants collaborent pour réaliser les opérations métier, gérer les erreurs et orchestrer les interactions. L’ajout du UC07 (Appariement interne &amp; Exécution) met en lumière la logique centrale du matching, la gestion des différents types d’ordres (DAY, IOC, FOK) et les alternatives métier, illustrant la complexité et la robustesse du moteur d’appariement.&#10;&#10;### Éléments&#10;- Services applicatifs (RegistrationService, AuthService, WalletService, OrderService, MatchingService)&#10;- Contrôleurs web (UserController, AuthController, WalletController, OrderController, OrderBookController)&#10;- Moteur d’appariement interne (MatchingService)&#10;- Adapters (UserAdapter, TransactionAdapter, OrderBookAdapter, etc.)&#10;- Persistance (JPA Repos)&#10;- Acteurs externes (Client)&#10;&#10;### Relations&#10;- Les contrôleurs reçoivent les requêtes des clients et délèguent aux services&#10;- Les services orchestrent la logique métier et interagissent avec les adapters&#10;- Les adapters font le lien avec la persistance et les systèmes externes&#10;- Les diagrammes d’activité synthétisent les étapes clés et les alternatives&#10;&#10;### Rationnel&#10;Cette vue permet de visualiser le flow des opérations, la gestion des exceptions, l’idempotence et la coordination entre les modules. Elle est essentielle pour valider la robustesse, la sécurité et la performance du système lors des opérations critiques. Elle aide à identifier les points de synchronisation, les risques de concurrence, et à optimiser la répartition des responsabilités. Elle est aussi précieuse pour l’analyse des scénarios d’erreur, la traçabilité des actions et la préparation des tests d’intégration et de non-régression.&#10;&#10;## 10. Vue Développement&#10;&#10;### Diagrammes&#10;- ![Diagramme de composants global](docs/architecture/4+1/developmentView/componentDiagram-global.png)&#10;- ![Diagramme de composants Auth Service](docs/architecture/4+1/developmentView/componentDiagram-auth.png)&#10;- ![Diagramme de composants Order Service](docs/architecture/4+1/developmentView/componentDiagram-order.png)&#10;- ![Diagramme de composants Wallet Service](docs/architecture/4+1/developmentView/componentDiagram-wallet.png)&#10;- ![Diagramme de composants Matching Service](docs/architecture/4+1/developmentView/componentDiagram-matching.png)&#10;- ![Diagramme de packages](docs/architecture/4+1/developmentView/BrokerX___Package_Diagram-BrokerX_Monolith___Package_Diagram.png)&#10;&#10;### Contexte&#10;La vue développement présente l’organisation du code source, la structure des dossiers, la modularité et les dépendances internes. Elle met en avant la façon dont le projet est découpé pour faciliter le travail des développeurs. Elle propose une double vision : une vue globale de l’architecture (tous les microservices et l’infrastructure) et une vue détaillée de la structure interne de chaque microservice métier.&#10;&#10;### Éléments&#10;- Packages principaux : adapters, domain, infrastructure&#10;- Composants techniques : contrôleurs, services, adapters, ports&#10;- Diagrammes de composants pour chaque microservice (auth, order, wallet, matching)&#10;- Structure des dossiers et conventions de nommage&#10;&#10;### Relations&#10;- Les packages sont organisés selon l’architecture hexagonale&#10;- Les dépendances entre modules sont explicites et maîtrisées&#10;- La séparation entre microservices et infrastructure est clairement illustrée&#10;- Les conventions facilitent la maintenance et l’évolution&#10;&#10;### Rationnel&#10;Cette vue facilite la compréhension du projet pour les développeurs, la maintenance et l’évolution du code. La double vision (globale + microservices) favorise la modularité, la réutilisabilité et la robustesse de l’application. Elle permet d’anticiper les impacts des changements, d’améliorer la qualité du code et de réduire les risques de dette technique. Elle est aussi utile pour l’onboarding, la gestion des versions et la collaboration entre équipes.&#10;&#10;## 11. Concepts transversaux&#10;&#10;### 11.1 Modèle de persistance et de domaine&#10;&#10;Avant d’aborder la structure des données, voici le diagramme ERD qui présente les principales entités persistées et leurs relations dans BrokerX. Ce schéma permet de visualiser la base du modèle de données et les liens entre les tables.&#10;&#10;#### Diagramme ERD&#10;![Diagramme ERD BrokerX](/docs/persistance/schemas/schema_er.png)&#10;&#10;Le tableau suivant détaille chaque table du modèle de persistance, avec une brève description de son rôle dans le système.&#10;&#10;#### Tableau 1. Tables de persistance&#10;&#10;| Nom                | Description                                                                                                      |&#10;|--------------------|------------------------------------------------------------------------------------------------------------------|&#10;| User               | Stocke les utilisateurs : email, mot de passe, nom, adresse, date de naissance, statut, solde, etc.              |&#10;| UserAudit          | Journalise les actions utilisateur : action, timestamp, document hash, IP, user agent, session token.            |&#10;| Transaction        | Stocke les transactions : montant, type (dépôt, retrait, achat, vente), statut, description, dates.              |&#10;| Order              | Stocke les ordres de trading : symbole, côté (achat/vente), type, quantité, prix, durée, statut, raison rejet.   |&#10;| MfaChallenge       | Stocke les défis MFA : code, date de création/expiration, état d’utilisation, IP, tentatives, verrouillage.      |&#10;| VerificationToken  | Stocke les tokens de vérification : hash du token, date d’expiration.                                            |&#10;&#10;Pour mieux comprendre la logique métier et les interactions entre les objets, le diagramme de classes ci-dessous illustre les entités principales et leurs relations dans le code.&#10;&#10;#### Diagramme de classes&#10;![Diagramme de classes BrokerX](/docs/persistance/schemas/schema_uml.png)&#10;&#10;Le tableau suivant présente chaque entité du modèle de domaine, avec une explication de son rôle métier.&#10;&#10;#### Tableau 2. Modèle de domaine&#10;&#10;| Nom d’entité         | Description métier                                                                                           |&#10;|----------------------|-------------------------------------------------------------------------------------------------------------|&#10;| User                 | Représente un utilisateur, gère l’activation, le rejet, le crédit du solde, et les statuts de compte.        |&#10;| UserAudit            | Permet de tracer toutes les actions importantes réalisées par un utilisateur.                                |&#10;| Transaction          | Représente une opération financière : dépôt, retrait, achat ou vente, avec gestion d’idempotence et statut.  |&#10;| Order                | Représente un ordre de trading, avec gestion du type, quantité, prix, durée, statut et raison de rejet.      |&#10;| MfaChallenge         | Gère les défis MFA, leur validité, expiration, utilisation et verrouillage en cas d’échecs.                  |&#10;| VerificationToken    | Gère les tokens de vérification pour l’activation de compte ou la récupération d’accès.                      |&#10;&#10;Puis, voici les principales méthodes métier de l’entité User, qui illustrent les opérations clés sur les comptes utilisateurs.&#10;&#10;#### Tableau 3. Méthodes métier importantes sur User&#10;&#10;| Méthode              | Description                                                                                                 |&#10;|----------------------|------------------------------------------------------------------------------------------------------------|&#10;| activate()           | Active le compte utilisateur.                                                                              |&#10;| reject()             | Rejette le compte utilisateur.                                                                             |&#10;| creditBalance(amount)| Ajoute un montant au solde de l’utilisateur.                                                               |&#10;&#10;#### Modèle de domaine&#10;&#10;Le diagramme de modèle de domaine ci-dessous synthétise les entités principales, leurs relations et les règles métier fondamentales de BrokerX. Il offre une vue conceptuelle du cœur métier, indépendante des choix techniques de persistance ou d’implémentation.&#10;&#10;![Diagramme du modèle de domaine](docs/ddd/mdd/MDD.png)&#10;&#10;Ce modèle permet de visualiser rapidement les objets métier, leurs interactions et les invariants structurants du domaine de courtage en ligne.&#10;&#10;### 11.2 Persistance&#10;&#10;BrokerX utilise une base de données PostgreSQL pour stocker toutes les données métier : utilisateurs, ordres, transactions, défis MFA, tokens de vérification et journaux d’audit. La base est persistée sur disque, et la localisation du fichier de données est gérée par la configuration Docker : le volume nommé `postgres_data` assure la persistance des données, même lors du redémarrage ou de la mise à jour des conteneurs.&#10;&#10;Toutes les opérations sur la base de données passent par JPA, avec Hibernate comme fournisseur. Les entités persistées sont décrites dans la section Domain Models. L’accès aux entités se fait exclusivement via les repositories Spring Data JPA, garantissant une abstraction et une sécurité des accès.&#10;&#10;Aucune donnée métier n’est stockée en mémoire ou dans des fichiers plats : toutes les informations critiques (identité, ordres, transactions, MFA, audit) sont centralisées dans PostgreSQL pour garantir la fiabilité, la traçabilité et la conformité réglementaire.&#10;&#10;Les fichiers statiques (templates Thymeleaf, ressources front-end) sont embarqués dans le JAR de l’application et servis par Spring Boot. Aucun fichier utilisateur (image, document, etc.) n’est stocké en dehors de la base : toutes les pièces justificatives ou documents d’audit sont référencés par leur hash dans la base, assurant l’intégrité et la non-répudiation.&#10;&#10;La configuration de la connexion à la base de données (URL, utilisateur, mot de passe) est externalisée dans les fichiers de propriétés et les variables d’environnement Docker, permettant une gestion flexible des environnements de développement, test et production.&#10;&#10;En résumé, la persistance des données dans BrokerX repose sur :&#10;- PostgreSQL pour toutes les données métier et d’audit&#10;- Docker volumes pour la durabilité des données&#10;- Spring Data JPA pour l’accès aux entités&#10;- Aucun stockage de fichiers binaires ou documents en dehors de la base&#10;&#10;Cette approche garantit la robustesse, la conformité et la portabilité du système, tout en facilitant la maintenance et la migration des données.&#10;&#10;#### 11.2.1 Choix ORM ou DAO&#10;Le projet BrokerX utilise l’ORM JPA/Hibernate pour la gestion de la persistance, car il offre une abstraction puissante entre le modèle objet Java et la base de données relationnelle. L’ORM permet de définir les entités métier avec l’annotation `@Entity`, de gérer les relations (OneToMany, ManyToOne, etc.), et de bénéficier de la génération automatique des requêtes SQL. Les accès aux données sont réalisés via des interfaces annotées `@Repository`, qui héritent des interfaces Spring Data (JpaRepository, CrudRepository). Cette approche réduit le code boilerplate, facilite la maintenance et la testabilité, et permet de profiter de la gestion transactionnelle native de Spring. Contrairement à une approche DAO classique, qui nécessite d’écrire manuellement chaque requête et chaque mapping, l’ORM centralise la logique de persistance et garantit la cohérence entre le code et la base. Ce choix est particulièrement pertinent pour BrokerX, qui doit gérer des entités complexes, des relations multiples et des évolutions fréquentes du modèle.&#10;&#10;#### 11.2.2 Transactions&#10;La gestion des transactions est assurée par l’annotation `@Transactional` sur les services et les repositories critiques (ex : WalletDepositService, OrderRepository, TransactionRepository, MfaChallengeAdapter). Spring gère automatiquement le début, la validation et le rollback des transactions, ce qui garantit l’atomicité des opérations et la cohérence des données. Les transactions couvrent les opérations sensibles comme les dépôts, les placements d’ordres, la gestion des MFA et la création de tokens. En cas d’erreur ou d’exception, toutes les modifications sont annulées pour éviter les incohérences.&#10;&#10;#### 11.2.3 Contraintes d’intégrité&#10;Les contraintes d’intégrité sont définies dans les scripts de migration SQL (Flyway) et dans les entités JPA. On retrouve des clés primaires, des clés étrangères, des contraintes d’unicité (ex : client_order_id), des contraintes NOT NULL, et des index pour optimiser les accès. Par exemple, la table `orders` possède une contrainte d’unicité sur `client_order_id` pour éviter les doublons, et toutes les relations sont sécurisées par des clés étrangères avec gestion des cascades. Les entités JPA reflètent ces contraintes via les annotations (@Id, @Column(nullable = false), @UniqueConstraint, @ManyToOne, etc.), ce qui assure une double validation côté code et côté base de données.&#10;&#10;#### 11.2.4 Migrations reproductibles&#10;Les migrations de schéma sont gérées par Flyway, avec des scripts SQL versionnés dans le dossier `db/migration`. Chaque modification de la structure de la base (création de table, ajout de colonne, contrainte, index) est tracée et appliquée de façon déterministe sur tous les environnements. Flyway garantit que chaque migration est idempotente, traçable et réversible. Cela permet de synchroniser la base entre les développeurs, les environnements de test et de production, et de revenir à un état antérieur en cas de problème. Les scripts sont testés et validés à chaque livraison, et la stratégie de versionnement évite les conflits et les pertes de données.&#10;&#10;#### 11.2.5 Données seed&#10;Des données de seed sont insérées via le script `V12__Insert_seed_data.sql`. Ce script permet de peupler la base avec des utilisateurs, des ordres, des transactions et des MFA pour les démonstrations et les tests. Les données seed facilitent la validation fonctionnelle, la démo du produit et la reproductibilité des scénarios métier. Elles sont conçues pour couvrir les principaux cas d’utilisation et garantir que le système démarre toujours dans un état cohérent et exploitable.&#10;&#10;&#10;### 11.3 Interface Utilisateur&#10;&#10;L’interface utilisateur de BrokerX est une application web classique, rendue côté serveur avec Thymeleaf et servie par Spring Boot. Elle propose une navigation fluide et sécurisée pour toutes les opérations de courtage : inscription, authentification MFA, gestion du portefeuille, passage d’ordres et consultation des historiques.&#10;&#10;L’UI utilise HTML, CSS et JavaScript, avec un thème sobre et responsive adapté aux besoins financiers. Toutes les interactions passent par des formulaires web et des appels REST sécurisés.&#10;&#10;Aucune interface mobile native ou SPA n’est fournie par défaut : l’accès se fait exclusivement via le navigateur web.&#10;&#10;### 11.4 Optimisation JavaScript et CSS&#10;&#10;L’optimisation des ressources JavaScript et CSS dans BrokerX est volontairement simple : aucun framework externe, gestionnaire de dépendances ou outil de minification n’est utilisé. Tout le code JavaScript et CSS est écrit en inline directement dans les templates Thymeleaf, ce qui évite toute dépendance supplémentaire et simplifie le déploiement.&#10;&#10;Aucune bibliothèque tierce (npm, bower, webjars, wro4j, etc.) n’est requise : l’ensemble des scripts et styles nécessaires à l’interface sont embarqués dans le JAR et servis par Spring Boot. Cette approche garantit la portabilité et la maintenance, tout en limitant la surface d’attaque et les risques liés aux mises à jour de dépendances externes.&#10;&#10;En résumé : tout le CSS et le JavaScript de BrokerX est inline, intégré dans les templates, sans optimisation ou minification avancée.&#10;&#10;### 11.5 Traitement des transactions&#10;&#10;BrokerX s’appuie sur Spring Boot pour la gestion des transactions locales au sein du JPA EntityManager. Toutes les opérations critiques (ordres, dépôts, retraits, MFA) sont traitées de façon transactionnelle pour garantir la cohérence des données. BrokerX ne supporte pas les transactions distribuées.&#10;&#10;### 11.6 Gestion de session&#10;&#10;BrokerX expose uniquement une API publique stateless : aucune gestion de session côté serveur. L’authentification et l’autorisation sont gérées par des tokens JWT et MFA, sans stockage de session.&#10;&#10;### 11.7 Sécurité&#10;&#10;La sécurité des endpoints API BrokerX repose sur l’authentification forte (MFA, JWT) et le chiffrement TLS. Les accès sont contrôlés par des rôles et toutes les opérations sensibles sont journalisées. Pour renforcer la sécurité, l’application peut être déployée derrière un proxy SSL ou avec la configuration TLS du conteneur Tomcat embarqué.&#10;&#10;Ce niveau de sécurité est adapté au type de données gérées et aux exigences réglementaires du secteur financier.&#10;&#10;### 11.8 Sûreté&#10;&#10;Aucune partie du système BrokerX ne présente de risque vital ou d’impact sur la sécurité physique des utilisateurs.&#10;&#10;### 11.9 Communications et intégration&#10;&#10;BrokerX communique principalement via des API REST sécurisées (HTTPS) et SMTP pour l’envoi d’e-mails. Aucune file de messages ou broker interne n’est utilisé : toutes les intégrations externes (KYC, notifications, audit) passent par des appels HTTP ou SMTP. Les messages ne sont pas persistés en dehors de la base de données métier.&#10;&#10;### 11.10 Vérifications de plausibilité et de validité&#10;&#10;La validation des types et des plages de données est assurée par des annotations JSR-303 sur les entités du domaine (ex : @NotNull). Les contrôleurs REST et services métier vérifient systématiquement la conformité des données reçues.&#10;&#10;Principales règles métier :&#10;- Un utilisateur désactivé ou rejeté ne peut pas passer d’ordre ni déposer de fonds (contrôlé dans UserService et OrderService).&#10;- Un ordre ne peut être placé que si le solde du portefeuille est suffisant (contrôlé dans OrderService).&#10;- Un dépôt doit être strictement positif (contrôlé dans WalletDepositService).&#10;&#10;Les contrôles sont réalisés à la fois au niveau des entités (annotations) et dans les services métier pour garantir la cohérence métier et la sécurité des opérations.&#10;&#10;### 11.11 Gestion des exceptions/erreurs&#10;&#10;Les erreurs de validation (données invalides, contraintes métier) sont mappées sur des codes HTTP appropriés (400, 403, 422) et retournées par les contrôleurs Spring. Les erreurs techniques (base de données, réseau, SMTP) sont loguées et peuvent entraîner l’échec de la requête ou une réponse 500.&#10;&#10;Les contrôleurs REST gèrent la conversion des exceptions en réponses HTTP standardisées. Les erreurs critiques sont journalisées pour analyse et audit.&#10;&#10;### 11.12 Journalisation et traçabilité&#10;&#10;BrokerX journalise toutes les actions critiques des utilisateurs (connexion, ordres, dépôts, MFA, vérification) dans la table UserAudit de la base PostgreSQL. Chaque entrée contient l’action, le timestamp, l’IP, le user agent et le token de session. Les transactions et les placements d'ordre sont également journalisés dans les tables Transaction et Order.&#10;&#10;La journalisation technique (logs applicatifs) est assurée via SLF4J et la configuration par défaut de Spring Boot : les logs sont envoyés en stdout et peuvent être collectés par l’infrastructure d’hébergement.&#10;&#10;La traçabilité métier est garantie par la persistance des logs d’audit en base, permettant l’analyse, la conformité et la détection d’anomalies. Les noms des loggers correspondent aux packages des classes pour faciliter l’identification des modules dans les logs.&#10;&#10;### 11.13 Configurabilité&#10;&#10;BrokerX utilise Spring Boot pour la gestion de la configuration. Les propriétés principales sont définies dans `src/main/resources/application.properties` pour le développement, et surchargées par `application-prod.properties` en production. Il est possible d’ajouter ou de modifier des propriétés via des variables d’environnement ou des fichiers spécifiques à l’environnement (ex : application-test.properties).&#10;&#10;Tableau 13. Principales propriétés de configuration BrokerX&#10;&#10;| Propriété                        | Valeur par défaut (dev)                                             | Description                                      |&#10;|----------------------------------|---------------------------------------------------------------------|--------------------------------------------------|&#10;| spring.application.name          | LOG430_BrokerX                                                      | Nom de l’application                             |&#10;| spring.datasource.url            | jdbc:postgresql://localhost:5432/brokerxdb                          | URL de la base de données PostgreSQL             |&#10;| spring.mail.host                 | smtp.gmail.com                                                      | Hôte SMTP pour l’envoi d’e-mails                 |&#10;| server.port                      | 8081 (dev) 8090 (prod)                                             | Port HTTP de l’application (dev)                 |&#10;| jwt.secret                       | your-256-bit-secret-key-for-development-change-in-production-please | Clé secrète JWT (dev)                            |&#10;| jwt.expiration                   | 86400000                                                            | Durée de validité des tokens JWT (ms)            |&#10;| spring.thymeleaf.cache           | false                                                               | Cache des templates Thymeleaf                    |&#10;| management.endpoints.web.exposure.include | health,info,metrics                                                 | Endpoints exposés pour le monitoring             |&#10;| app.base-url                     | http://localhost:8090 (prod)                                        | URL de base de l’application (prod)              |&#10;| logging.level.com.monolitique.log430 | INFO (prod)                                                         | Niveau de log pour le code métier                |&#10;&#10;La configuration est centralisée et facilement modifiable selon l’environnement (développement, production). Les propriétés sensibles (mots de passe, clés) doivent être gérées via des variables d’environnement en production.&#10;&#10;### 11.14 Internationalisation&#10;&#10;L’unique langue supportée par BrokerX est le français. Il n’existe aucun mécanisme d’internationalisation dans l’interface utilisateur ou l’API, et aucune évolution n’est prévue à ce sujet.&#10;&#10;### 11.15 Migration&#10;&#10;BrokerX est une application développée from scratch en Java/Spring Boot. Aucune migration de données ou d’application antérieure n’a été réalisée : toutes les données ont été créées directement dans la base PostgreSQL du projet.&#10;&#10;### 11.16 Testabilité&#10;&#10;Le projet contient des tests automatisés (JUnit) dans le dossier standard `src/test/java` d’un projet Maven. Les tests couvrent les services métier, les contrôleurs web et les entités principales. Les tests sont exécutés à chaque build Maven et ne doivent pas être ignorés.&#10;&#10;### 11.17 Gestion du build&#10;&#10;L’application se construit avec Maven sans dépendances externes hors Maven. Toutes les étapes (compilation, tests, packaging) sont automatisées via le pipeline CI/CD. Le build produit un JAR exécutable prêt à être déployé dans Docker.&#10;&#10;## 12. Décisions d'architecture&#10;&#10;### 12.1 Architecture hexagonale vs MVC&#10;&#10;# ADR 001 : Architecture hexagonale vs MVC&#10;&#10;**Statut** : Acceptée\&#10;**Date** : 2025-09-23&#10;&#10;## Contexte&#10;Le projet BrokerX doit adopter une structure claire, évolutive et adaptée à la complexité métier (gestion d’ordres, portefeuille, sécurité, intégration de services externes). Deux styles sont envisagés : MVC (Model-View-Controller) et Hexagonal (Ports &amp; Adapters).&#10;## Décision&#10;Nous choisissons l’architecture hexagonale pour BrokerX. Ce style permet une séparation stricte du domaine métier des dépendances techniques, facilite l’intégration de nouveaux services, la testabilité, et prépare le projet à une éventuelle modularisation ou migration vers des microservices.&#10;## Conséquences&#10;- Le domaine métier est indépendant des frameworks et de l’infrastructure.&#10;- Les ports et adapters facilitent l’intégration de services externes.&#10;- La structure est plus modulaire et évolutive qu’un MVC classique.&#10;- La courbe d’apprentissage peut être plus élevée pour les nouveaux développeurs.&#10;- La documentation et la communication sont facilitées.&#10;&#10;### 12.2 Persistance des données&#10;&#10;# ADR 002 : Persistance des données&#10;&#10;**Statut** : Acceptée\&#10;**Date** : 2025-09-23&#10;&#10;## Contexte&#10;BrokerX doit stocker de façon fiable les utilisateurs, ordres, transactions, stocks, et assurer la traçabilité (audit). Plusieurs options sont possibles : base de données relationnelle, NoSQL, fichiers, etc.&#10;&#10;## Décision&#10;Nous retenons une base de données relationnelle (ex : PostgreSQL) pour la persistance principale. Les ports du domaine définissent les interfaces, et les adapters d’infrastructure implémentent l’accès aux données via JPA/Hibernate.&#10;&#10;## Conséquences&#10;- Les modèles métier sont mappés sur des tables relationnelles.&#10;- La cohérence transactionnelle est assurée.&#10;- La migration vers d’autres solutions (NoSQL, cloud) reste possible via de nouveaux adapters.&#10;- Les requêtes complexes et la traçabilité sont facilitées.&#10;- La gestion des migrations de schéma doit être planifiée.&#10;&#10;### 12.3 Journalisation des opérations utilisateur&#10;&#10;# Journalisation des opérations utilisateur&#10;&#10;**Statut** : Acceptée\&#10;**Date** : 2025-09-23&#10;&#10;## Contexte&#10;La traçabilité des actions des utilisateurs est essentielle pour la conformité réglementaire (KYC/AML), la sécurité et l’analyse métier. Plusieurs approches sont possibles : logs applicatifs, solutions externes (ELK, SIEM), ou persistance dédiée en base de données. Il faut garantir la robustesse, la facilité d’accès et la pérennité des données d’audit.&#10;&#10;## Décision&#10;Nous avons choisi de créer une table dédiée `UserAudit` dans la base de données. Toutes les opérations importantes (inscription, authentification, ordres, transactions, vérifications) sont journalisées avec les informations pertinentes (horodatage, identifiant utilisateur, type d’action, détails). Cette solution permet une requêtabilité directe, une intégration simple avec le domaine, et une conformité aux exigences internes et externes.&#10;&#10;## Conséquences&#10;- La traçabilité est centralisée et facilement accessible pour les audits et analyses.&#10;- La solution est évolutive : de nouveaux types d’événements peuvent être ajoutés facilement.&#10;- Les performances sont maîtrisées, car la journalisation est intégrée au modèle de données.&#10;- L’intégration avec des outils externes reste possible via export ou synchronisation.&#10;- La gestion de la volumétrie et de la rétention des données doit être planifiée pour éviter l’engorgement.&#10;&#10;## 12.4 Justification de l'architecture&#10;&#10;# Architecture de BrokerX&#10;&#10;BrokerX adopte une **architecture hexagonale (Ports &amp; Adapters)**.&#10;&#10;### Justification du choix&#10;- **Séparation stricte du domaine métier** : Le cœur métier (modèles, services, logique métier) est isolé des dépendances techniques (frameworks, bases de données, API externes). Les règles métier restent stables et compréhensibles, même si la technologie évolue.&#10;- **Évolutivité et adaptabilité** : L’architecture hexagonale facilite l’ajout ou le remplacement de services externes (paiement, données de marché, audit) sans impacter le domaine. Par exemple, un changement de fournisseur de paiement n’affecte que l’adapter correspondant.&#10;- **Facilité de test et de validation métier** : Le découplage permet de tester le domaine indépendamment des frameworks, ce qui accélère la validation métier et la détection des régressions. Les ports facilitent la création de mocks pour les tests unitaires et d’intégration.&#10;- **Dépendances dirigées et absence de cycles** : Les dépendances sont orientées du domaine vers les ports, puis vers les adapters, ce qui évite les cycles et rend l’architecture plus robuste et maintenable.&#10;- **Réduction du couplage** : Le domaine ne dépend jamais de l’infrastructure ou des frameworks, ce qui permet de migrer vers une autre technologie (ex : changement de framework, passage à une architecture microservices) sans refonte du métier.&#10;- **Conformité réglementaire et sécurité** : En isolant le métier, on facilite la traçabilité et la conformité (audit, KYC, MFA), car les règles métier sont centralisées et documentées.&#10;- **Clarté et communication** : Ce style favorise une documentation claire et une compréhension partagée entre les équipes métier et technique, car chaque couche a une responsabilité bien définie.&#10;&#10;Ce style répond aux besoins de BrokerX : évolutivité, conformité réglementaire, sécurité, intégration de nouveaux services externes, et robustesse face aux changements technologiques.&#10;&#10;---&#10;&#10;### Architecture monolithique et évolutivité&#10;&#10;BrokerX est une application monolithique : toutes les fonctionnalités métier, la logique applicative et l’intégration technique sont regroupées dans un même déploiement.&#10;- **Un seul artefact déployé** : toutes les couches (domaine, application, infrastructure, configuration) sont assemblées et exécutées ensemble, ce qui simplifie la gestion et la supervision.&#10;- **Centralisation des règles métier** : la logique métier et les processus sont gérés dans un même espace, ce qui facilite la cohérence et la traçabilité.&#10;- **Gestion transactionnelle fiable** : les opérations complexes (dépôt, placement d’ordre, audit) bénéficient d’une gestion transactionnelle robuste, sans complexité distribuée.&#10;- **Modularité interne** : chaque couche et chaque port/adaptateur est clairement séparé, ce qui permet d’ajouter, modifier ou remplacer des modules sans impacter le reste du système.&#10;- **Préparation à la modularisation** : les ports et adapters peuvent être extraits vers des microservices ou modules indépendants si le besoin de scalabilité ou d’évolution se présente.&#10;- **Facilité d’intégration de nouveaux services** : l’ajout de services externes (paiement, données de marché, audit) se fait via de nouveaux adapters, sans toucher au domaine métier.&#10;- **Clarté et robustesse** : la séparation stricte des responsabilités rend le code plus lisible, plus maintenable et facilite l’intégration de nouveaux développeurs.&#10;&#10;Ainsi, BrokerX combine la simplicité et la robustesse du monolithe avec la modularité et l’évolutivité de l’architecture hexagonale.&#10;&#10;---&#10;&#10;### Description des couches et dépendances&#10;&#10;L’architecture se compose des couches suivantes :&#10;- **Domaine** : Entités métier (User, Order, Transaction, Stock…), services métier, ports (interfaces du domaine). Cette couche porte la logique métier, les règles de validation, et les invariants du système.&#10;- **Application** : Orchestration des cas d’utilisation, coordination des services métier, gestion de la logique applicative. Elle fait le lien entre les besoins métier et les interactions techniques, sans dépendre des frameworks.&#10;- **Infrastructure** : Implémentation des ports (adapters), persistance, sécurité, intégration avec les services externes. Cette couche traduit les besoins métier en opérations techniques (accès base de données, appels API, gestion de la sécurité).&#10;- **Configuration** : Paramétrage de la sécurité, des dépendances, et du démarrage de l’application. Elle assemble les composants, injecte les dépendances, et gère l’environnement d’exécution.&#10;&#10;#### Organisation des dépendances&#10;- Le domaine reste totalement indépendant des frameworks et de l’infrastructure, ce qui garantit sa stabilité et sa portabilité.&#10;- Les ports définissent les points d’extension et d’intégration ; les adapters les implémentent pour chaque technologie ou service externe.&#10;- La configuration injecte les dépendances sans créer de cycles, ce qui permet de maîtriser l’ordre d’initialisation et la gestion des ressources.&#10;- Les dépendances sont toujours dirigées, ce qui évite les effets de bord et facilite la maintenance.&#10;&#10;---&#10;&#10;### Contrôle du couplage aux frameworks&#10;&#10;- Le couplage aux frameworks (Spring, persistance, sécurité) est strictement limité à l’infrastructure et à la configuration. Cela permet de changer de framework ou de technologie sans impacter le métier.&#10;- Le domaine ne contient aucune annotation ou dépendance technique, ce qui garantit sa pureté et sa testabilité.&#10;- Le cœur métier peut être réutilisé ou migré vers une autre architecture (microservices, serverless) sans dépendance forte, ce qui protège l’investissement métier.&#10;- Les tests sont facilités, car le domaine peut être mocké ou simulé sans dépendance technique.&#10;&#10;---&#10;&#10;### Illustration de l’architecture&#10;&#10;![Diagramme d'architecture hexagonale](docs/architecture/justifications/architectureDiagram.png)&#10;&#10;---&#10;&#10;### Justification globale&#10;&#10;L’architecture hexagonale appliquée au monolithe BrokerX :&#10;- Permet de faire évoluer la plateforme sans refonte majeure, en isolant le métier des choix techniques.&#10;- Sécurise le domaine contre les changements techniques et réglementaires, en centralisant les règles métier.&#10;- Facilite l’intégration de nouveaux services externes (paiement, données de marché, audit) grâce aux ports et adapters.&#10;- Répond aux exigences de clarté, évolutivité et conformité de l’analyse métier, tout en favorisant la communication entre les équipes.&#10;- Garantit la robustesse et la maintenabilité du système, en évitant les cycles et en maîtrisant les dépendances.&#10;- Prépare la plateforme à une éventuelle migration vers une architecture distribuée ou microservices, sans perte de logique métier.&#10;&#10;&#10;&#10;## 13. Scénarios de Qualité&#10;&#10;### 13.1 Arbre de qualité&#10;&#10;L’arbre de qualité ci-dessous synthétise les principaux attributs de qualité visés par BrokerX : sécurité, performance, disponibilité, maintenabilité, testabilité, évolutivité, traçabilité et conformité. Chaque branche détaille les sous-attributs et les priorités associées.&#10;&#10;![Arbre de qualité BrokerX](./qualityTree.png)&#10;&#10;### 13.2 Scénarios d’évaluation&#10;&#10;**Testabilité / Couverture**&#10;- L’utilisation de JaCoCo pendant le développement et dans le pipeline CI/CD doit garantir un taux de couverture de code d’au moins 95 % sur les classes métier critiques (services, contrôleurs, entités).&#10;&#10;**Testabilité / Indépendance des services externes**&#10;- L’architecture doit permettre de tester toute logique métier dépendant de services externes (ex : envoi d’e-mails, accès base de données, fournisseurs de données de marché) sans avoir besoin de ces services réels. Toutes les dépendances externes doivent être mockables via des interfaces ou des adapters.&#10;&#10;*Exemple :*&#10;- Le service d’envoi de codes MFA utilise une interface EmailProvider. Lors des tests, un mock de cette interface permet de valider la logique métier sans connexion SMTP réelle.&#10;&#10;**Sécurité / MFA et KYC**&#10;- Toute tentative d’accès à une ressource protégée sans authentification MFA ou sans vérification KYC doit être bloquée et journalisée. Les tests automatisés doivent couvrir ces scénarios d’accès non autorisé.&#10;&#10;**Performance / Traitement des ordres**&#10;- Le système doit traiter un ordre d’achat ou de vente en moins de 500 ms (P95) même sous charge. Des tests de performance automatisés doivent valider ce critère.&#10;&#10;**Disponibilité / Résilience**&#10;- En cas de panne d’un composant non critique (ex : service d’e-mail), le système doit continuer à accepter les ordres et journaliser l’incident. Des scénarios de test doivent simuler la défaillance de chaque dépendance externe.&#10;&#10;**Maintenabilité / Évolutivité**&#10;- L’ajout d’un nouveau type d’ordre ou d’un nouveau service externe doit pouvoir se faire sans modification majeure du domaine métier. Des tests d’intégration valident la non-régression lors de l’ajout de nouvelles fonctionnalités.&#10;&#10;**Traçabilité / Audit**&#10;- Toute opération critique (inscription, dépôt, ordre, MFA) doit être journalisée dans la base. Des tests automatisés vérifient la présence des logs d’audit pour chaque scénario métier clé.&#10;&#10;## 14. Risques Techniques&#10;&#10;BrokerX a été conçu selon des standards éprouvés et bénéficie d’une architecture robuste, éprouvée en environnement de développement et de test. À ce jour, aucune faille technique majeure n’a été identifiée pour les scénarios d’utilisation prévus.&#10;&#10;Cependant, certains risques techniques subsistent :&#10;&#10;- **Risque de corruption de la base PostgreSQL** en cas d’arrêt brutal du serveur (panne matérielle, crash OS, coupure électrique). Ce risque est atténué par l’utilisation de volumes Docker persistants et la mise en place de sauvegardes régulières de la base de données.&#10;- **Dépendance à des services externes (SMTP, fournisseurs de données de marché)** : une indisponibilité temporaire de ces services peut impacter certaines fonctionnalités (ex : envoi de codes MFA, notifications). L’architecture prévoit une gestion de la résilience : les ordres et opérations critiques restent acceptés et journalisés même en cas de panne d’un service externe.&#10;- **Montée en charge** : si le nombre d’utilisateurs ou le volume d’ordres croît très rapidement, des ajustements d’infrastructure (scaling, tuning PostgreSQL, optimisation du code) pourraient être nécessaires. Des tests de charge réguliers et une surveillance proactive permettent d’anticiper ce risque.&#10;- **Sécurité** : bien que l’authentification MFA, le KYC et le chiffrement soient en place, le risque d’attaque (phishing, brute force, faille 0-day) ne peut jamais être totalement éliminé.&#10;&#10;En résumé, les principaux risques techniques sont identifiés, documentés et font l’objet de mesures de mitigation adaptées à la criticité de BrokerX.&#10;&#10;## 15. Glossaire&#10;&#10;Le glossaire ci-dessous recense les principaux termes métier utilisés dans BrokerX, en lien direct avec le code et les processus métier de la plateforme.&#10;&#10;Tableau 14. Glossaire métier BrokerX&#10;&#10;| Terme              | Définition                                                                                         |&#10;|--------------------|----------------------------------------------------------------------------------------------------|&#10;| Utilisateur        | Personne inscrite sur la plateforme BrokerX, pouvant effectuer des opérations et gérer son compte. |&#10;| Portefeuille       | Espace virtuel associé à un utilisateur, regroupant son solde en monnaie fiduciaire et ses actifs. |&#10;| Solde              | Montant total disponible dans le portefeuille d’un utilisateur pour effectuer des opérations.      |&#10;| Transaction        | Mouvement de fonds tel qu’un dépôt ou un retrait, ou opération d’achat/vente d’un actif.           |&#10;| Ordre              | Demande formelle d’un utilisateur pour acheter ou vendre un stock. Un ordre contient le symbole, la quantité, le type (marché/limite), le prix (si limite), la durée et le sens (achat/vente). |&#10;| Type d’ordre       | Catégorie d’ordre : Marché (exécuté au prix courant du marché, sans garantie de prix) ou Limite (exécuté uniquement si le prix cible est atteint). |&#10;| Statut d’ordre     | État d’avancement d’un ordre : Pending (en attente), Active (en cours), Rejected (refusé), Completed (exécuté), Expired (périmé). |&#10;| Durée d’ordre      | Période de validité d’un ordre : DAY (valide jusqu’à la fin de la journée), IOC (Immediate or Cancel : exécuté immédiatement ou annulé), FOK (Fill or Kill : exécuté en totalité ou annulé). |&#10;| Bande de prix      | Plage de variation autorisée du prix d’un stock sur une période donnée, pour limiter la volatilité et protéger les investisseurs. |&#10;| Tick Size          | Incrément minimal de variation du prix d’un stock : le prix d’un ordre doit être un multiple du tick size défini pour ce stock. |&#10;| Stock              | Actif financier (ex : action) disponible à l’achat ou à la vente sur BrokerX. Chaque stock possède un symbole, un nom, un prix, une bande de prix et un tick size. |&#10;| ClientOrderId      | Identifiant unique fourni par le client pour tracer et retrouver un ordre dans le système.         |&#10;| KYC                | Processus de vérification d’identité réglementaire (Know Your Customer).                           |&#10;| MFA                | Authentification multi-facteurs pour renforcer la sécurité d’accès à la plateforme.                |&#10;| OTP                | Mot de passe à usage unique, utilisé pour la vérification d’identité ou l’authentification.        |&#10;| Statut utilisateur | État du compte utilisateur : Pending (en attente), Active (actif), Rejected (refusé), Suspended (suspendu). |&#10;| Rejet d’ordre      | Motif pour lequel un ordre est refusé (ex : fonds insuffisants, violation de bande de prix, tick size non respecté, quantité invalide). |&#10;| SimulatedPayment   | Processus simulé de règlement d’un dépôt ou d’un retrait, utilisé pour tester la plateforme.       |&#10;| Audit              | Journalisation des opérations importantes (création de compte, ordres, transactions, etc.).        |&#10;| Session            | Période d’activité authentifiée d’un utilisateur sur la plateforme.                                |&#10;| Rôle utilisateur   | Catégorie d’accès d’un utilisateur (ex : Client, Administrateur).                                 |&#10;| Idempotency Key    | Clé unique permettant d’éviter la duplication d’une opération lors de réessais.                    |&#10;| Statut transaction | État d’une transaction : Pending (en attente), Settled (réglée), Failed (échouée), Completed (terminée). |&#10;| VérificationToken  | Jeton utilisé pour confirmer l’identité ou l’inscription d’un utilisateur.                        |&#10;| Side               | Sens d’un ordre : Achat (Buy) ou Vente (Sell).                                                    |&#10;| Description        | Texte explicatif associé à une transaction ou un ordre.                                           |&#10;| Timestamp          | Date et heure d’enregistrement d’une opération ou d’un ordre.                                     |&#10;| PreTradeValidation | Contrôle métier effectué avant l’acceptation d’un ordre (pouvoir d’achat, règles de prix, tick size, bande de prix, quantité, etc.). |&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wallet-service/src/main/resources/db/migration/V3__rename_walletEntity_to_wallet.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wallet-service/src/main/resources/db/migration/V3__rename_walletEntity_to_wallet.sql" />
              <option name="updatedContent" value="ALTER TABLE walletEntity RENAME TO wallet;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wallet-service/src/main/resources/db/migration/V6__add_price_to_stock_rule.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wallet-service/src/main/resources/db/migration/V6__add_price_to_stock_rule.sql" />
              <option name="updatedContent" value="ALTER TABLE stock_rule ADD COLUMN price DECIMAL(18,2) NOT NULL DEFAULT 0;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/order-service/src/main/java/com/microservices/log430/orderservice/adapters/messaging/publishers/EventPublisher.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/order-service/src/main/java/com/microservices/log430/orderservice/adapters/messaging/publishers/EventPublisher.java" />
              <option name="originalContent" value="package com.microservices.log430.orderservice.adapters.messaging.publishers;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;&#10;import com.microservices.log430.orderservice.adapters.persistence.entities.OutboxEventEntity;&#10;import com.microservices.log430.orderservice.adapters.persistence.repository.OutboxEventRepository;&#10;import com.microservices.log430.orderservice.adapters.messaging.outbox.OutboxService;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import org.springframework.amqp.core.TopicExchange;&#10;import org.springframework.amqp.rabbit.core.RabbitTemplate;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.Instant;&#10;import java.util.List;&#10;&#10;/**&#10; * Service responsable de publier les événements depuis l'outbox vers RabbitMQ&#10; */&#10;@Service&#10;public class EventPublisher {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(EventPublisher.class);&#10;&#10;    private final RabbitTemplate rabbitTemplate;&#10;    private final TopicExchange orderExchange;&#10;    private final OutboxEventRepository outboxEventRepository;&#10;    private final OutboxService outboxService;&#10;    private final ObjectMapper objectMapper;&#10;&#10;    @Value(&quot;${messaging.routing-key.order-placed}&quot;)&#10;    private String orderPlacedRoutingKey;&#10;&#10;    @Autowired&#10;    public EventPublisher(RabbitTemplate rabbitTemplate,&#10;                         TopicExchange orderExchange,&#10;                         OutboxEventRepository outboxEventRepository,&#10;                         OutboxService outboxService) {&#10;        this.rabbitTemplate = rabbitTemplate;&#10;        this.orderExchange = orderExchange;&#10;        this.outboxEventRepository = outboxEventRepository;&#10;        this.outboxService = outboxService;&#10;        this.objectMapper = new ObjectMapper();&#10;        this.objectMapper.registerModule(new JavaTimeModule());&#10;    }&#10;&#10;    /**&#10;     * Traite tous les événements en attente dans l'outbox&#10;     */&#10;    public void processOutboxEvents() {&#10;        logger.debug(&quot;Début du traitement des événements outbox&quot;);&#10;&#10;        List&lt;OutboxEventEntity&gt; events = outboxEventRepository&#10;            .findUnprocessedEventsReadyForProcessing(Instant.now());&#10;&#10;        if (events.isEmpty()) {&#10;            logger.debug(&quot;Aucun événement à traiter dans l'outbox&quot;);&#10;            return;&#10;        }&#10;&#10;        logger.info(&quot;Traitement de {} événements depuis l'outbox&quot;, events.size());&#10;&#10;        for (OutboxEventEntity event : events) {&#10;            try {&#10;                publishEvent(event);&#10;                outboxService.markEventAsProcessed(event.getId());&#10;&#10;            } catch (Exception e) {&#10;                logger.error(&quot;Erreur lors de la publication de l'événement: eventId={}, type={}&quot;,&#10;                           event.getEventId(), event.getEventType(), e);&#10;                outboxService.markEventAsFailed(event.getId(), e.getMessage());&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Publie un événement spécifique vers RabbitMQ&#10;     */&#10;    private void publishEvent(OutboxEventEntity event) {&#10;        String routingKey = getRoutingKeyForEventType(event.getEventType());&#10;&#10;        logger.info(&quot;Publication de l'événement: eventId={}, type={}, routingKey={}&quot;,&#10;                   event.getEventId(), event.getEventType(), routingKey);&#10;&#10;        try {&#10;            // Le payload est déjà sérialisé en JSON dans l'outbox&#10;            Object eventData = objectMapper.readValue(event.getPayload(), Object.class);&#10;&#10;            rabbitTemplate.convertAndSend(&#10;                orderExchange.getName(),&#10;                routingKey,&#10;                eventData&#10;            );&#10;&#10;            logger.info(&quot;Événement publié avec succès: eventId={}&quot;, event.getEventId());&#10;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Erreur lors de la publication vers RabbitMQ: eventId={}&quot;, event.getEventId(), e);&#10;            throw new RuntimeException(&quot;Erreur de publication RabbitMQ&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Détermine la routing key basée sur le type d'événement&#10;     */&#10;    private String getRoutingKeyForEventType(String eventType) {&#10;        return switch (eventType) {&#10;            case &quot;ORDER_PLACED&quot; -&gt; orderPlacedRoutingKey;&#10;            default -&gt; throw new IllegalArgumentException(&quot;Type d'événement non supporté: &quot; + eventType);&#10;        };&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.microservices.log430.orderservice.adapters.messaging.publishers;&#10;&#10;import com.fasterxml.jackson.databind.ObjectMapper;&#10;import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;&#10;import com.microservices.log430.orderservice.adapters.persistence.entities.OutboxEventEntity;&#10;import com.microservices.log430.orderservice.adapters.persistence.repository.OutboxEventRepository;&#10;import com.microservices.log430.orderservice.adapters.messaging.outbox.OutboxService;&#10;import org.slf4j.Logger;&#10;import org.slf4j.LoggerFactory;&#10;import org.springframework.amqp.core.TopicExchange;&#10;import org.springframework.amqp.rabbit.core.RabbitTemplate;&#10;import org.springframework.beans.factory.annotation.Autowired;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.stereotype.Service;&#10;&#10;import java.time.Instant;&#10;import java.util.List;&#10;&#10;/**&#10; * Service responsable de publier les événements depuis l'outbox vers RabbitMQ&#10; */&#10;@Service&#10;public class EventPublisher {&#10;&#10;    private static final Logger logger = LoggerFactory.getLogger(EventPublisher.class);&#10;&#10;    private final RabbitTemplate rabbitTemplate;&#10;    private final TopicExchange orderExchange;&#10;    private final OutboxEventRepository outboxEventRepository;&#10;    private final OutboxService outboxService;&#10;    private final ObjectMapper objectMapper;&#10;&#10;    @Value(&quot;${messaging.routing-key.order-placed}&quot;)&#10;    private String orderPlacedRoutingKey;&#10;&#10;    @Autowired&#10;    public EventPublisher(RabbitTemplate rabbitTemplate,&#10;                         TopicExchange orderExchange,&#10;                         OutboxEventRepository outboxEventRepository,&#10;                         OutboxService outboxService) {&#10;        this.rabbitTemplate = rabbitTemplate;&#10;        this.orderExchange = orderExchange;&#10;        this.outboxEventRepository = outboxEventRepository;&#10;        this.outboxService = outboxService;&#10;        this.objectMapper = new ObjectMapper();&#10;        this.objectMapper.registerModule(new JavaTimeModule());&#10;    }&#10;&#10;    /**&#10;     * Traite tous les événements en attente dans l'outbox&#10;     */&#10;    public void processOutboxEvents() {&#10;        logger.debug(&quot;Début du traitement des événements outbox&quot;);&#10;&#10;        List&lt;OutboxEventEntity&gt; events = outboxEventRepository&#10;            .findUnprocessedEventsReadyForProcessing(Instant.now());&#10;&#10;        if (events.isEmpty()) {&#10;            logger.debug(&quot;Aucun événement à traiter dans l'outbox&quot;);&#10;            return;&#10;        }&#10;&#10;        logger.info(&quot;Traitement de {} événements depuis l'outbox&quot;, events.size());&#10;&#10;        for (OutboxEventEntity event : events) {&#10;            try {&#10;                publishEvent(event);&#10;                outboxService.markEventAsProcessed(event.getId());&#10;&#10;            } catch (Exception e) {&#10;                logger.error(&quot;Erreur lors de la publication de l'événement: eventId={}, type={}&quot;,&#10;                           event.getEventId(), event.getEventType(), e);&#10;                outboxService.markEventAsFailed(event.getId(), e.getMessage());&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Publie un événement spécifique vers RabbitMQ&#10;     */&#10;    private void publishEvent(OutboxEventEntity event) {&#10;        String routingKey = getRoutingKeyForEventType(event.getEventType());&#10;&#10;        logger.info(&quot;Publication de l'événement: eventId={}, type={}, routingKey={}&quot;,&#10;                   event.getEventId(), event.getEventType(), routingKey);&#10;&#10;        try {&#10;            // Le payload est déjà sérialisé en JSON dans l'outbox&#10;            Object eventData = objectMapper.readValue(event.getPayload(), Object.class);&#10;&#10;            rabbitTemplate.convertAndSend(&#10;                orderExchange.getName(),&#10;                routingKey,&#10;                eventData&#10;            );&#10;&#10;            logger.info(&quot;Événement publié avec succès: eventId={}&quot;, event.getEventId());&#10;&#10;        } catch (Exception e) {&#10;            logger.error(&quot;Erreur lors de la publication vers RabbitMQ: eventId={}&quot;, event.getEventId(), e);&#10;            throw new RuntimeException(&quot;Erreur de publication RabbitMQ&quot;, e);&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Détermine la routing key basée sur le type d'événement&#10;     */&#10;    private String getRoutingKeyForEventType(String eventType) {&#10;        return switch (eventType) {&#10;            case &quot;ORDER_PLACED&quot; -&gt; orderPlacedRoutingKey;&#10;            default -&gt; throw new IllegalArgumentException(&quot;Type d'événement non supporté: &quot; + eventType);&#10;        };&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wallet-service/src/main/resources/db/migration/V3__rename_walletEntity_to_wallet.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wallet-service/src/main/resources/db/migration/V3__rename_walletEntity_to_wallet.sql" />
              <option name="updatedContent" value="ALTER TABLE walletEntity RENAME TO wallet;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/wallet-service/src/main/resources/db/migration/V6__add_price_to_stock_rule.sql">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/wallet-service/src/main/resources/db/migration/V6__add_price_to_stock_rule.sql" />
              <option name="updatedContent" value="ALTER TABLE stock_rule ADD COLUMN price DECIMAL(18,2) NOT NULL DEFAULT 0;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>
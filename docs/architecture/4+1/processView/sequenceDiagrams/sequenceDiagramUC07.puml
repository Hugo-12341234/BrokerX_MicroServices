@startuml
' UC-07 — Matching d'un ordre (BrokerX)

title Sequence Diagram\nUC-07 — Matching d'un ordre (microservices)

skinparam ParticipantPadding 8
skinparam BoxPadding 6
skinparam Shadowing false
skinparam ArrowColor #2c3e50
skinparam ActorStyle awesome
autonumber

participant "Event Bus" as EventBus
participant "OrderPlacedEventListener" as Listener
participant "MatchingService" as Service
participant "Domain(OrderBook, ExecutionReport)" as Domain
participant "Adapters (OrderBook, Execution)" as Adapters
participant "Persistence (JPA Repos)" as Persistence
participant "OutboxService" as Outbox
participant "OutboxScheduler" as Scheduler
participant "EventPublisher" as Publisher

note over Persistence
Matching engine : nettoyage expirés, priorité prix/temps, gestion FOK/IOC/DAY
end note

== Réception événement ORDER_PLACED ==
EventBus -> Listener: handleOrderPlaced(OrderPlacedEvent)
Listener -> Service: processOrderPlacedEvent(OrderPlacedEvent)

Service -> Service: convertOrderPlacedEventToOrderBook(event)
Service -> Service: matchOrder(orderBook)

== Nettoyage et insertion ==
Service -> Service: cleanupExpiredDayOrders(symbol)
Service -> Adapters: save(orderBook)
Adapters -> Persistence: save(orderBook)
Persistence --> Adapters: OrderBook(WORKING)
Adapters --> Service: OrderBook(WORKING)

== Recherche candidats de matching ==
Service -> Adapters: findAllBySymbol(symbol)
Adapters -> Persistence: findAllBySymbol(symbol)
Persistence --> Adapters: List<OrderBook>
Adapters --> Service: List<OrderBook>

Service -> Service: filterOppositeOrders(orders, side)
Service -> Service: sortByPriceTimePriority(oppositeOrders)

== Matching loop pour chaque candidat ==
loop pour chaque candidat compatible
    Service -> Service: checkPriceMatch(orderBook, candidate)

    alt prix compatible et quantités disponibles
        Service -> Domain: new ExecutionReport(fillQty, fillPrice, ...)
        Domain --> Service: ExecutionReport

        Service -> Adapters: save(ExecutionReport)
        Adapters -> Persistence: save(ExecutionReport)
        Persistence --> Adapters: ExecutionReport
        Adapters --> Service: ExecutionReport

        Service -> Domain: updateOrderStatus(orderBook, candidate)
        Service -> Adapters: save(orderBook)
        Service -> Adapters: save(candidate)
        Adapters -> Persistence: save(orderBook)
        Adapters -> Persistence: save(candidate)
    end
end

== Gestion durée d'ordre (FOK/IOC/DAY) ==
alt FOK non complètement rempli
    Service -> Domain: setStatus(CANCELLED)
    Service -> Adapters: save(orderBook)
    Service -> Adapters: deleteById(orderBook.id)
else IOC (exécution partielle)
    Service -> Domain: setStatus(CANCELLED/PARTIALLYFILLED)
    Service -> Adapters: save(orderBook)
    Service -> Adapters: deleteById(orderBook.id)
else DAY (reste dans le carnet ou expiré)
    alt ordre expiré (24h)
        Service -> Domain: setStatus(CANCELLED)
        Service -> Adapters: save(orderBook)
        Service -> Adapters: deleteById(orderBook.id)
    else ordre actif
        Service -> Domain: setStatus(WORKING/PARTIALLYFILLED)
        Service -> Adapters: save(orderBook)
    end
end

== Publication des événements de résultat ==
alt matching réussi
    Service -> Service: publishOrderMatched(MatchingResult, OrderPlacedEvent)
    Service -> Outbox: saveEvent("ORDER_MATCHED", OrderMatchedEvent)

    Service -> Service: publishDetailedNotifications(MatchingResult, OrderPlacedEvent)
    Service -> Outbox: saveEvent("NOTIFICATION_SEND", NotificationEvent)

    loop pour chaque exécution
        Service -> Service: publishExecutionNotifications(ExecutionReport)
        Service -> Outbox: saveEvent("NOTIFICATION_SEND", NotificationEvent)
    end
else matching échoué
    Service -> Service: publishOrderRejected(OrderPlacedEvent, rejectReason)
    Service -> Outbox: saveEvent("ORDER_REJECTED", OrderRejectedEvent)

    Service -> Outbox: saveEvent("NOTIFICATION_SEND", NotificationEvent)
end

Scheduler -> Publisher: processOutboxEvents()
Publisher -> Publisher: publishEvent()
Publisher --> Publisher: RabbitMQ publish

@enduml

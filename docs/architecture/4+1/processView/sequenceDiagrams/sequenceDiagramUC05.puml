@startuml
' UC-05 — Placement d'un ordre (BrokerX)

title Sequence Diagram\nUC-05 — Placement d'un ordre (microservices)

skinparam ParticipantPadding 8
skinparam BoxPadding 6
skinparam Shadowing false
skinparam ArrowColor #2c3e50
skinparam ActorStyle awesome
autonumber

actor Client
participant APIGateway
participant OrderController
participant OrderService
participant PreTradeValidationService
participant "Domain(Order)" as Domain
participant "Adapters (Order, Stock)" as Adapters
participant "Persistence (JPA Repos)" as Persistence
participant "API Wallet" as WalletAPI
participant "OutboxService" as Outbox
participant "Event Publisher" as EventBus
participant "MatchingEventListener" as Listener

note over Persistence
Contrôles pré-trade : statut du compte, pouvoir d'achat, bandes, ticks, short-sell, etc.
end note

== Soumission de l'ordre ==
Client -> APIGateway: POST localhost:8079/api/v1/orders/place\nOrderRequest(symbol, side, type, timeInForce, quantity, limitPrice, clientOrderId)
APIGateway -> OrderController: POST /api/v1/orders/place\nOrderRequest(symbol, side, type, timeInForce, quantity, limitPrice, clientOrderId)
OrderController -> OrderService: placeOrder(symbol, side, type, timeInForce, quantity, limitPrice, userID)

OrderService -> Adapters: findByClientOrderId(clientOrderId)
Adapters -> Persistence: findByClientOrderId(clientOrderId)
Persistence --> Adapters: Optional<Order>
Adapters --> OrderService: Optional<Order>

opt idempotence (ordre déjà placé)
    OrderService --> OrderController: Order(orderId, status)
    OrderController --> APIGateway: 200 OrderResponse(orderId, status)
    APIGateway --> Client: 200 OrderResponse(orderId, status)
end

OrderService -> WalletAPI: GET /api/v1/wallet/
WalletAPI --> OrderService: Wallet(userId, balance, stockPositions)

opt erreur de l'appel API ou wallet inexistant
  OrderService --> OrderController: Exception(500, "Portefeuille introuvable ou réponse invalide")
  OrderController --> APIGateway: 500 Error("Portefeuille introuvable ou réponse invalide")
  APIGateway --> Client: 500 Error("Portefeuille introuvable ou réponse invalide")
end

OrderService -> PreTradeValidationService: validateOrder(user, symbol, side, type, timeInForce, quantity, limitPrice)

alt erreur de validation ou pré-trade (quantité, prix, pouvoir d'achat, bande de prix, tick size, short-sell, etc.)
  PreTradeValidationService --> OrderService: ValidationError(raison)
    OrderService -> Domain: créer l'ordre(REJECTED)
      Domain --> OrderService: Order
      OrderService -> Adapters: save(Order)
    Adapters -> Persistence: save(Order)
    Persistence --> Adapters: Order(REJECTED)
    Adapters --> OrderService: Order(REJECTED)

    OrderService -> Outbox: saveEvent("NOTIFICATION_SEND", NotificationEvent)
    Outbox --> OrderService: ack

  OrderService --> OrderController: Order(REJECTED)
  OrderController --> APIGateway: 400 OrderResponse(REJETÉ, raison)
  APIGateway --> Client: 400 OrderResponse(REJETÉ, raison)
else ordre accepté
    PreTradeValidationService --> OrderService: ValidationSuccess
  OrderService -> Domain: créer l'ordre(WORKING)
    Domain --> OrderService: Order
    OrderService -> Adapters: save(Order)
  Adapters -> Persistence: save(Order)
  Persistence --> Adapters: Order(WORKING)
  Adapters --> OrderService: Order(WORKING)

  OrderService -> Outbox: saveEvent("ORDER_PLACED", OrderPlacedEvent)
  Outbox --> OrderService: ack

  OrderService --> OrderController: Order(WORKING)
  OrderController --> APIGateway: 200 OK OrderResponse(orderId, "WORKING")
  APIGateway --> Client: 200 OK OrderResponse(orderId, "WORKING")
end

== Publication asynchrone des événements ==
EventBus -> Outbox: processOutboxEvents()
Outbox -> EventBus: publishEvent(OrderPlacedEvent)
EventBus --> EventBus: RabbitMQ publish

== Réception événement de matching ==
EventBus -> Listener: onOrderMatchedEvent(OrderMatchedEvent)
Listener -> OrderService: processOrderMatched(OrderMatchedEvent)

OrderService -> Adapters: findById(orderId)
Adapters -> Persistence: findById(orderId)
Persistence --> Adapters: Order
Adapters --> OrderService: Order

alt ordre trouvé et matching réussi
    OrderService -> Domain: updateOrderStatus(FILLED/PARTIALLYFILLED)
    OrderService -> Adapters: save(Order)
    Adapters -> Persistence: save(Order)

    OrderService -> WalletAPI: POST /api/v1/wallet/updateWallet\n(userId, symbol, quantity, cashAmount)
    WalletAPI --> OrderService: OK

    OrderService -> Outbox: saveEvent("NOTIFICATION_SEND", NotificationEvent)
    Outbox --> OrderService: ack
else ordre non trouvé ou erreur matching
    OrderService -> Domain: updateOrderStatus(REJECTED)
    OrderService -> Adapters: save(Order)
    Adapters -> Persistence: save(Order)

    OrderService -> Outbox: saveEvent("NOTIFICATION_SEND", NotificationEvent)
    Outbox --> OrderService: ack
end

== Réception événement de rejet ==
EventBus -> Listener: onOrderRejectedEvent(OrderRejectedEvent)
Listener -> OrderService: processOrderRejected(OrderRejectedEvent)

OrderService -> Adapters: findById(orderId)
OrderService -> Domain: updateOrderStatus(REJECTED)
OrderService -> Adapters: save(Order)

OrderService -> Outbox: saveEvent("NOTIFICATION_SEND", NotificationEvent)
Outbox --> OrderService: ack

@enduml

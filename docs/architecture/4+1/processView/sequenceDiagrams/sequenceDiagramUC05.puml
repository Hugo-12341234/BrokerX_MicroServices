@startuml
' UC-05 — Placement d’un ordre (BrokerX)

title Sequence Diagram\nUC-05 — Placement d’un ordre (microservices)

skinparam ParticipantPadding 8
skinparam BoxPadding 6
skinparam Shadowing false
skinparam ArrowColor #2c3e50
skinparam ActorStyle awesome
autonumber

actor Client
participant OrderController
participant OrderService
participant PreTradeValidationService
participant "Domain(Order)" as Domain
participant "Adapters (Order, Stock)" as Adapters
participant "Persistence (JPA Repos)" as Persistence
participant "API Wallet" as WalletAPI
participant "API Matching" as MatchingAPI

note over Persistence
Contrôles pré-trade : statut du compte, pouvoir d’achat, bandes, ticks, short-sell, etc.
end note

== Soumission de l’ordre ==
Client -> OrderController: POST /api/v1/orders/place\nOrderRequest(symbol, side, type, timeInForce, quantity, limitPrice, clientOrderId)
OrderController -> OrderService: placeOrder(symbol, side, type, timeInForce, quantity, limitPrice, userID)

OrderService -> Adapters: findByClientOrderId(clientOrderId)
Adapters -> Persistence: findByClientOrderId(clientOrderId)
Persistence --> Adapters: Optional<Order>
Adapters --> OrderService: Optional<Order>

opt idempotence (ordre déjà placé)
    OrderService --> OrderController: Order(orderId, status)
    OrderController --> Client: 200 OrderResponse(orderId, status)
end

OrderService -> WalletAPI: GET /api/v1/wallet/
WalletAPI --> OrderService: Wallet(userId, balance, stockPositions)

opt erreur de l'appel API ou wallet inexistant
  OrderService --> OrderController: Exception(500, "Portefeuille introuvable ou réponse invalide")
  OrderController --> Client: 500 Error("Portefeuille introuvable ou réponse invalide")
end

OrderService -> PreTradeValidationService: validateOrder(user, symbol, side, type, timeInForce, quantity, limitPrice)

alt erreur de validation ou pré-trade (quantité, prix, pouvoir d’achat, bande de prix, tick size, short-sell, etc.)
  PreTradeValidationService --> OrderService: ValidationError(raison)
    OrderService -> Domain: créer l'ordre(REJECTED)
      Domain --> OrderService: Order
      OrderService -> Adapters: save(Order)
    Adapters -> Persistence: save(Order)
    Persistence --> Adapters: Order(REJECTED)
    Adapters --> OrderService: Order(REJECTED)
  OrderService --> OrderController: Order(REJECTED)
  OrderController --> Client: 400 OrderResponse(REJETÉ, raison)
else ordre accepté
    PreTradeValidationService --> OrderService: ValidationSuccess
  OrderService -> Domain: créer l'ordre(ACCEPTED)
    Domain --> OrderService: Order
    OrderService -> Adapters: save(Order)
  Adapters -> Persistence: save(Order)
  Persistence --> Adapters: Order(ACCEPTED)
  Adapters --> OrderService: Order(ACCEPTED)

  ' Appel API vers le matching service
  OrderService -> MatchingAPI: POST /api/v1/matching/matchOrder\n(order: Order)
  alt erreur matching
    MatchingAPI --> OrderService: error
    OrderService -> Domain: markAsRejected(order)
    OrderService -> Adapters: save(Order)
    Adapters -> Persistence: save(Order)
    Persistence --> Adapters: Order(REJECTED)
    Adapters --> OrderService: Order(REJECTED)
    OrderService --> OrderController: Order(REJECTED)
    OrderController --> Client: 400 OrderResponse(REJETÉ, raison)
  else matching réussi
    MatchingAPI --> OrderService: success
    ' Appel API vers le wallet service pour mise à jour portefeuille
    OrderService -> WalletAPI: POST /api/v1/wallet/updateWallet\n(solde: BigDecimal, stockPositions: Map<String, Integer>)
    WalletAPI --> OrderService: OK
    OrderService --> OrderController: Order(ACCEPTED)
    OrderController --> Client: 200 OK OrderResponse(orderId, "ACCEPTÉ")
  end
end

@enduml
